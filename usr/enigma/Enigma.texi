\input texinfo.tex    @c -*-Enigma-*-
@c %**start of header
@setfilename Enigma
@settitle Enigma
@c %**end of header

@c Constants
@set name Enigma

@c General format
@paragraphindent none
@exampleindent 0

@c Title and front page
@node Top
@ifhtml
@center @titlefont{@value{name}}
@end ifhtml
@ifnothtml
@top @center @value{name}
@end ifnothtml

Enigma is a simulator of the cypher machine used by the Germans during 2nd
world war. This typing machine was based on switches and rotors that
translated letters.@*
The rotors are statically defined off line in a XML file. The choice of rotors,
their initial position and the switches are provided as arguments to the
simulator.

@menu
* Enigma command line:    Command line.    Arguments of Enigma program.
* Enigma behaviour:       Behaviour.       Behaviour of Enigma program.
* Enigma algorithm:       Algorithm.       Coding and decoding algorithm.
* Enigma design:          Enigma design.   General design of Enigma program.
* Coder design:           Coder design.    Design of Enigma coder.
* Compatibility:          Compatibility.   Compatibility with the real machine.
* Automatic config:       Automatic.       Automatic Enigma configurations.
* Random config:          Random.          Random Enigma configurations.

@end menu

@node Command line, Behaviour, Top, Top
@chapter Enigma command line

@verbatim
Syntax: enigma <reflector_def> [ <rotor_defs>  ] [ <rotor_inits> ]
               [ <switches> ] [ <first_index> ] [ <last_index> ]

   <reflector_def> ::= <reflector_name>[@<upperletter>]
   <rotor_defs>    ::= -r{ [#]<rotor_name>@<ring_offset>[#] }
   <rotor_inits>   ::= -i{ <upperletter> }
   <switches>      ::= -s{ <upperletter><upperletter> }
   <first_index>   ::= -f<positive>       (default 1)
   <last_index>    ::= -l<positive>       (default none)
   <ring_setting>  ::= <upperletter>
   <upperletter>   ::= A .. Z
@end verbatim

Up to 4 rotors can be used and one reflector must be defined.@*
They must have different names.@*
There must be as many rotor offsets as rotors defined.@*
Ex, for rotors I (fastest), IV and Beta (slowest): "Beta@@A#IV@@Q#I@@F".
@sp 1
Semantic:

@itemize @minus
@item The reflector is defined by its name and the optional letter of offset (constant).

@item Up to 4 rotors can be defined and one reflector must be defined.
They must all have different names.@*
All rotors and reflectors are defined in a XML configuration file (name from
ENV ENIGMA_CONF_FILE, default "enigma.xml"). They must all have differenti
names.@*
Rotor carries are the offsets at which next rotor will turn together with
current. Rotors with no carry can only appear at first position (slowest) and
don't turn.@*
@verbatim
ABCDEFGHIJKLMNOPQRSTUVWXYZ
|                        |
BCDEFGHIJKLMNOPQRSTUVWXYZA
@end verbatim

For a reflector, the definition must be symetrical and with no identity.@*

In the command line, the rotors (optional) definition consists in <rotor_defs>
(rotor name @@ ring setting, separated by #) and <rotor_inits>, the initial
position of each rotor. First rotor defined is the slowest and is the one
crossed just before the reflector. So for command line "I IV V", the coding
will go through V, IV, I, reflector, then back.

@item The switches definition follows the same logic but defines only the letters
that change in the coding (all other letters are kept unchanged). ex:
AZBJMGYC
Note that max 13 pairs can be defined, with no identity and each letter can
appear at most once (implicit symetry).

@item The first_index number defines the offset of input text from which the
decoding starts (default 1).

@item The last number defines the last offset of input text after which the
decoding stops (default none).
@end itemize

@node Behaviour, Algorithm, Command line, Top
@chapter Enigma behaviour
@table @asis
@item Data flows:
The program reads a byte flow to code from stdin and puts the corresponding
coded flow on stdout. Uppercase letters are coded the standard enigma way (see
below). Lower letters are converted to uppercase, codded, then converted to
lowercase. Other bytes are not coded (they are put unchanged on stdout).

@item Turning rules and coding ways:
Rotors turn before the coding. The Enigma double stepping behaviour applies.

@item Coding rule:
The input letter (uppercase) is encoded through the switches, through all
the rotors, then through the refelctor (this is called encoding).
It is then encoded the other way through all the rotors and the switch (this
is called decoding). The complete cycle is called coding.
@verbatim
      + <------ +-----+ <- +-----+ <- +--------+ <- Input
 |Reflector|    |Rotor|    |Rotor|    |Switches|
      + ------> +-----+ -> +-----+ -> +--------+ -> Output
@end verbatim
@end table

@node Algorithm, Enigma design, Behaviour, Top
@chapter Coding and decoding algorithm
Letters are represented by a modulus 0 .. 25, the Id (A->0, B->1, .. Z->25).@*
Coding X through a rotor or through the reflector means:
@itemize @minus
@item The current offset O of the rotor is nb of increments - ring setting
and the offset O of the reflector is constant
@item Input I is X + O
@item Output U from I is got from the scrambler definition of the rotor
@item The final result R is U - O
@end itemize

Decoding is similar except that I = X - O, the scrambler is inverted and then
R is U + O.
@sp 1
A scrambler is made of an array of 26 different Ids.

@node Enigma design, Coder design, Algorithm, Top
@chapter General Design
The software is decomposed into the following components:
@itemize @minus
@item A Definition that checks and loads the configuration file, and
initializes the machine from it.

@item The Io_Manager, that reads and writes bytes. It supports:@*
Skip (Nb_Bytes);  @minus{}@minus{} From input flow@*
Read -> Byte;     @minus{}@minus{} Or raises End_Error@*
Write (Byte);

@item The Coder, that encodes uppercase characters. It supports:
Init;   @minus{}@minus{} Using the Definition to init the enigma@*
Encode (Upper_Char) -> Upper_Char;

@item The main inits the scrambler factory then the Coder, then run
the scheduler.
@verbatim
  Io_Manager.Skip (Nb_Bytes);  -- From the command line
  loop
    Byte := Io_Manager.Read;
    case Byte_Kind is
      when Upper_Char =>
        Byte := Coder.Encode (Byte);
      when Lower_Char =>
        Byte := Lower_Char (Coder.Encode (Upper_Char (Byte)));
      when others =>
        null;  -- Byte unchanged
    end case;
    Io_Manager.Write (Byte);
  end loop;
@end verbatim
@end itemize

@node Coder design, Compatibility, Enigma design, Top
@chapter Coder Design
The initialization consists in getting the definitions,
making the coders through the factory and storing them.
Encoding an upper character consists in:
@itemize @minus
@item Turning the rotors (double stepping applies)
@item Encoding through the switches
@item Encoding through the rotors (right to left, fastest to slowest)
@item Encoding through the reflector
@item Decoding through the rotors (left to right, slowest to fastest)
@item Encoding through the switches
@item Returning the coded upper character.
@end itemize

@node Compatibility, Automatic, Coder design, Top
@chapter Compatibility
Enigma can simulate Enigma M3 and M4 machines, but also allows more combinations
than the physical machines (rotors are from 0 to 4, no restriction on the
combination of first (slowest) rotor and reflector, offset of reflector...).@*
M3 compatible configurations shall use a reflector from A to C with no offset
and 3 rotors from I to VIII.@*
M4 compatible configurations shall use a reflector Bthin or Cthin with no
offset, a rotor Beta and 3 rotors from I to VIII.

@node Automatic, Random, Compatibility, Top
@chapter Automatic configuration
Automatic enigma setting considering the date.@*
@verbatim
Usage: def_enigma [ -text ]   <date> | today | rnd | <text_key> | <enigma_key>
  date ::= dd/mm/YYyy
  <enigma_key> ::= <reflector> [ <rotors> <rotors_init> ] [ <switches> ]
@end verbatim

If rnd, generates a random switch sequence, 3 to 4 rotors (see B.).
reflector (A to Cthin).@*
If date, generates a switch sequence, 3 rotors and the reflector from the date.@*
If no arg, same with current date.@*
If text_key, displays the key from text jey (see @ref{automatic-output, Text output}).@*
If enigma_key, check and displays enigma key@*
If -text, also generates text of key (see @ref{automatic-output, Text output}).@*
@sp 1
Rotors (at least 10) and reflectors (at least 5) are defined in enigma.xml.

@section Normal generation
The date is either provided or is current date.@*
The date that is considered is DAYNAME DAYNUM MONTHNAME.@*
There are 3 rotors.

@subsection Reflector
The Reflector num is 1 to 3, computed from DAYNUM:@*
01->1, 02->2, 03 -> 3, 04 -> 1 ...@*
Its offset is 0 (A).

@subsection Rotors
There are 3 rotors:
@itemize @minus
@item The first rotor number is the unit of DAYNUM, with 1->1 .. 10->10, 11->1.
@item The second rotor is the tenth of DAYNUM, with 0..9->1, 10..19->2,
20..29->3 and 30..31 ->4. If used by first rotor, then add 1.
@item The third rotor is month num rem 10 with 1->1 .. 10->10, 11->1...
If used by first or second rotor, then add 1.
@end itemize
The rotor ring offsets are the first three letters of DAYNAME respectively.@*
The rotor initial offsets are the first three letters of MONTHNAME respectively.

@subsection Switches
The switches definition is got from the letters of DAYNAME and MONTHNAME, with
criteria of unicity, no identity and even number (and max 26 letters).@*
Ex MONDAY DECEMBER -> MONDAYECBR.

@subsection Output format
The reflector setting is <reflector_name><reflector_offset>@*
The optional setting of rotors is -r<rotor>#<rotor>....@*
where each <rotor> is <rotor_name>@@<ring_offset>
The initial rotors positions are -i@{<letter>@} with as may letter as rotors
number.@*
The optional switchs are -s@{<letter><letter>@}@*
Ex: Cthin@@B -rI@@G#IV@@C#VII@@Q#II@@G -iTLDO -sTPWASFXIEVZCYLBN

@section Random generation
The reflector is random from 1 to 3 if 3 rotors, from 1 to 2 (meaning Bthin and
Cthin, num 4 and 5) if 4 rotors. It has no offset (A).@*
The rotors are a random number (3 to 4 included) of random rotors,
each with a random ring offset letter and a random initial offset letter.@*
If 4 rotors, the 1st is 1 or 2, meaning Beta or Gamma (num 11 and 12).@*
The other rotors are from 1st to 10th.@*
The switch is a random list (1 to 12 included) of random pairs of letters

@section @anchor{automatic-output}Text output
If optionnal -text is provided, the key (random, from current date or from
provided date) is translated to text:
@itemize @w
@item The switch definition is displayed, followed by JJJ (letter cannot appear
twice at first of pair, nor twice as second of pair, in switch definition).
@item Then the rotors are displayed but their number in letters instead of name,
each with the ring offset then the initial offset.
@item Then the reflector num in letters and its offset.
@item Then the reflector offset is repeated (so that, like a rotor, it is a number
in letters then two letters), then a 'Z' (which cannot start a digit in
letters), which marks the end). Example@*
-rV@@M#III@@O#I@@N B@@Y -iJAN -> MONDAYJUJJJFIVEMJTHREEOAONENNTWOYYZ@*
@end itemize

Note that even in case of 4 rotors the 4th rotor is ONE or TWO and the reflector
is ONE or TWO.
@sp 1
If the key is provided as text, then it is transformed into normal opions.


@node Random, , Automatic, Top
@chapter Random configuration
Random generation of configuration.
@verbatim
Usage: enigmacode -c | -d  [ <date> ]
   <date>  ::=  jj/mm/YYyy
@end verbatim

@section Coding
A random key is generated in arguments and text:@*
def_enigma rnd -text@*
This displays <key_args> and <key_text>.
@sp 1
The key in text is coded, with a key generated from the current day, at the
beginning of the coded file:@*
echo -n "<key_text>" | enigmadef <date>  > <coded_file>@*
<date> can be an explicit date (dd/mm/yyy) or "today"
@sp 1
The input file is coded with the random key and appended to the coded file
enigma <key_args>  < <input_file>  >> <coded_file>

@section Decoding
Extract temporary in the decoded file the 68 first characters from the coded
file, with the key generated from the current (today) or a provided date:@*
<txtkey>=enigma `def_enigma <date>` -l68@*
(68 because 26 for switch, 3 for JJJ, 4 * 7 + 3 (5 is longest number in letters
e.g. SEVEN) for the 4 max rotors, 5 + 3 (number+offset twice+"Z") for the
reflector.@*
txtkey=`enigma $datekey -l68 < <coded_file>`
@sp 1
Look in the temporary result for the "JJJ" then read the key in text, until
<num_in_text><letter><letter><num_in_text>. Note the offset <offset> of the
irst letter following this sequence.@*
numkey=`def_enigma <textkey>` ; start=$?
@sp 1
Decode the remaining text with the key:@*
enigma <numkey> -f<start>  < <coded_file>  > <decoded_file>

@bye

