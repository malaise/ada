Enigma
======

Enigma is a simulator of the cypher machine used by the Germans during 2nd
world war. This typing machine was based on switches and rotors that
translated letters.

The rotors are statically defined off line in a XML file. The choice of
rotors, their initial position and the switches are provided as arguments to
the simulator.

Enigma command line
-------------------

Syntax: enigma <reflector_def> [ <rotor_defs>  ] [ <rotor_inits> ]
               [ <switches> ] [ <first_index> ] [ <last_index> ]

   <reflector_def> ::= <reflector_name>[@<upperletter>]
   <rotor_defs>    ::= -r{ [#]<rotor_name>@<ring_offset>[#] }
   <rotor_inits>   ::= -i{ <upperletter> }
   <switches>      ::= -s{ <upperletter><upperletter> }
   <first_index>   ::= -f<positive>       (default 1)
   <last_index>    ::= -l<positive>       (default none)
   <ring_setting>  ::= <upperletter>
   <upperletter>   ::= A .. Z

Up to 4 rotors can be used and one reflector must be defined.

They must have different names.

There must be as many rotor_inits as rotors_defs.

Ex, for rotors I (fastest), IV and Beta (slowest):
--------------------------------------
Beta@A#IV@Q#I@F.
--------------------------------------

Semantic:

- The reflector is defined by its name and the optional letter of offset
(constant).

- Up to 4 rotors can be defined and one reflector must be defined. They
must all have different names.
+
All rotors and reflectors are defined in a XML configuration file (name from
ENV ENIGMA_CONF_FILE, default "enigma.xml"). They must all have different names.
+
Rotor carries are the offsets at which next rotor will turn together with
current. Rotors with no carry can only appear at first position (slowest) and
don't turn.

     ABCDEFGHIJKLMNOPQRSTUVWXYZ
     |                        |
     BCDEFGHIJKLMNOPQRSTUVWXYZA
+
For a reflector, the definition must be symetrical and with no identity.
+
In the command line, the rotors (optional) definition consists in
<rotor_defs> (rotor name @ ring setting, separated by #) and
<rotor_inits>, the initial position of each rotor. First rotor defined
is the slowest and is the one crossed just before the reflector. So for
command line "I IV V", the coding will go through V, IV, I, reflector,
then back.

- The switches definition follows the same logic but defines only the
letters that change in the coding (all other letters are kept
unchanged). ex: AZBJMGYC Note that max 13 pairs can be defined, with no
identity and each letter can appear at most once (implicit symetry).

- The first_index number defines the offset of input text from which the
decoding starts (default 1).

- The last number defines the last offset of input text after which the
decoding stops (default none).

Enigma behaviour
----------------
Data flows:;;
     The program reads a byte flow to code from stdin and puts the
     corresponding coded flow on stdout. Uppercase letters are coded the
     standard enigma way (see below). Lower letters are converted to
     uppercase, codded, then converted to lowercase. Other bytes are not
     coded (they are put unchanged on stdout).

Turning rules and coding ways:;;
     Rotors turn before the coding. The Enigma double stepping behaviour
     applies.

Coding rule:;;
     The input letter (uppercase) is encoded through the switches, through all
     the rotors, then through the refelctor (this is called encoding).  It is
     then encoded the other way through all the rotors and the switch (this
     is called decoding). The complete cycle is called coding.

      + <------ +-----+ <- +-----+ <- +--------+ <- Input
 |Reflector|    |Rotor|    |Rotor|    |Switches|
      + ------> +-----+ -> +-----+ -> +--------+ -> Output

Coding and decoding algorithm
-----------------------------
Letters are represented by a modulus 0 .. 25, the Id (A->0, B->1, .. Z->25).
Coding X through a rotor or through the reflector means:

- The current offset O of the rotor is nb of increments - ring setting and
the offset O of the reflector is constant

- Input I is X + O

- Output U from I is got from the scrambler definition of the rotor

- The final result R is U - O

Decoding is similar except that I = X - O, the scrambler is inverted and then
R is U + O.

A scrambler is made of an array of 26 different Ids.

General Design
--------------
The software is decomposed into the following components:

- A Definition that checks and loads the configuration file, and initializes
the machine from it.

- The Io_Manager, that reads and writes bytes. It supports:

  Skip (Nb_Bytes);  -- From input flow
  Read -> Byte;     -- Or raises End_Error
  Write (Byte);

- The Coder, that encodes uppercase characters. It supports:

  Init;   -- Using the Definition to init the enigma
  Encode (Upper_Char) -> Upper_Char;

- The main inits the scrambler factory then the Coder, then run the scheduler.

  Io_Manager.Skip (Nb_Bytes);  -- From the command line
  loop
    Byte := Io_Manager.Read;
    case Byte_Kind is
      when Upper_Char =>
        Byte := Coder.Encode (Byte);
      when Lower_Char =>
        Byte := Lower_Char (Coder.Encode (Upper_Char (Byte)));
      when others =>
        null;  -- Byte unchanged
    end case;
    Io_Manager.Write (Byte);
  end loop;

Coder Design
------------
The initialization consists in getting the definitions, making the coders
through the factory and storing them.

Encoding an upper character consists in:

- Turning the rotors (double stepping applies)

- Encoding through the switches

- Encoding through the rotors (right to left, fastest to slowest)

- Encoding through the reflector

- Decoding through the rotors (left to right, slowest to fastest)

- Encoding through the switches

- Returning the coded upper character.

Compatibility
-------------
Enigma can simulate Enigma M3 and M4 machines, but also allows more
combinations than the physical machines (rotors are from 0 to 4, no
restriction on the combination of first (slowest) rotor and reflector, offset
of reflector...).

M3 compatible configurations shall use a reflector from A to C with no offset
and 3 rotors from I to VIII.

M4 compatible configurations shall use a reflector Bthin or Cthin with no
offset, a rotor Beta and 3 rotors from I to VIII.

Automatic configuration
-----------------------
Automatic enigma setting considering the date.

  Usage: def_enigma [ -text ]   <date> | today | rnd | <text_key> | <enigma_key>
    date ::= dd/mm/YYyy
    <enigma_key> ::= <reflector> [ <rotors> <rotors_init> ] [ <switches> ]

If rnd, generates a random switch sequence, 3 to 4 rotors and a random
reflector (A to Cthin).

If date, generates a switch sequence, 3 rotors and the reflector from the
date.

If no arg, same with current date.

If text_key, displays the key from text jey (see <<XT-TextOutput,Text Output>>).

If enigma_key, check and displays enigma key.

If -text, also generates text of key (see <<XT-TextOutput,Text Output>>).

Rotors (at least 10) and reflectors (at least 5) are defined in enigma.xml.

Normal generation
~~~~~~~~~~~~~~~~~
The date is either provided or is current date.

The date that is considered is DAYNAME DAYNUM MONTHNAME.

There are 3 rotors.

Reflector
^^^^^^^^^
The Reflector num is 1 to 3, computed from DAYNUM:

01->1, 02->2, 03 -> 3, 04 -> 1...

Its offset is 0 (A).

Rotors
^^^^^^
There are 3 rotors:

- The first rotor number is the unit of DAYNUM, with 1->1 .. 10->10, 11->1.

- The second rotor is the tenth of DAYNUM, with 0..9->1, 10..19->2,
20..29->3 and 30..31 ->4. If used by first rotor, then add 1.

- The third rotor is month num rem 10 with 1->1 .. 10->10, 11->1...  If
used by first or second rotor, then add 1.

The rotor ring offsets are the first three letters of DAYNAME respectively.

The rotor initial offsets are the first three letters of MONTHNAME
respectively.

Switches
^^^^^^^^
The switches definition is got from the letters of DAYNAME and MONTHNAME, with
criteria of unicity, no identity and even number (and max 26 letters).

Ex MONDAY DECEMBER -> MONDAYECBR.

Output format
^^^^^^^^^^^^^
The reflector setting is <reflector_name><reflector_offset>

The optional setting of rotors is -r<rotor>#<rotor>....
where each <rotor> is <rotor_name>@<ring_offset> The initial rotors positions
are -i{<letter>} with as may letter as rotors number.

The optional switchs are -s{<letter><letter>}

--------------------------------------
Ex: Cthin@B -rI@G#IV@C#VII@Q#II@G -iTLDO -sTPWASFXIEVZCYLBN
--------------------------------------

Random generation
~~~~~~~~~~~~~~~~~
The reflector is random from 1 to 3 if 3 rotors, from 1 to 2 (meaning Bthin
and Cthin, num 4 and 5) if 4 rotors. It has no offset (A).

The rotors are a random number (3 to 4 included) of random rotors, each with
a random ring offset letter and a random initial offset letter.

If 4 rotors, the 1st is 1 or 2, meaning Beta or Gamma (num 11 and 12).

The other rotors are from 1st to 10th.

The switch is a random list (1 to 12 included) of random pairs of letters

[[XT-TextOutput]]
Text output
~~~~~~~~~~~
If optionnal -text is provided, the key (random, from current date or from
provided date) is translated to text:

- The switch definition is displayed, followed by JJJ (letter cannot appear
twice at first of pair, nor twice as second of pair, in switch
definition).

- Then the rotors are displayed but their number in letters instead of
name, each with the ring offset then the initial offset.

- Then the reflector num in letters and its offset.

- Then the reflector offset is repeated (so that, like a rotor, it is a
number in letters then two letters), then a ''Z'' (which cannot start a
digit in letters), which marks the end). Example
--------------------------------------
-rV@M#III@O#I@N B@Y -iJAN -> MONDAYJUJJJFIVEMJTHREEOAONENNTWOYYZ
--------------------------------------

Note that even in case of 4 rotors the 4th rotor is ONE or TWO and the
reflector is ONE or TWO.

If the key is provided as text, then it is transformed into normal opions.

Random configuration
--------------------
Random generation of configuration.

  Usage: enigmacode -c | -d  [ <date> ]
    <date>  ::=  jj/mm/YYyy

Coding
~~~~~~

A random key is generated in arguments and text:
--------------------------------------
def_enigma rnd -text
--------------------------------------
This displays <key_args> and <key_text>.

The key in text is coded, with a key generated from the current day, at the
beginning of the coded file:
--------------------------------------
echo -n "<key_text>" | enigmadef <date>  > <coded_file>
--------------------------------------
<date> can be an explicit date (dd/mm/yyy) or "today"

The input file is coded with the random key and appended to the coded file
--------------------------------------
enigma <key_args>  < <input_file>  >> <coded_file>
--------------------------------------

Decoding
~~~~~~~~
Extract temporary in the decoded file the 68 first characters from the coded
file, (68 because 26 for switch, 3 for JJJ, 4 * 7 + 3 (5 is longest number in
letters e.g. SEVEN) for the 4 max rotors, 5 + 3 (number+offset twice+"Z") for
the reflector.

Use the key generated from the current date (today) or a provided date:
--------------------------------------
datekey=`def_enigma <date>`
txtkey=`enigma $datekey -l68 < <coded_file>`
--------------------------------------

Look in the temporary result for the "JJJ" then read the key in text, until
<num_in_text><letter><letter><num_in_text>. Note the offset <offset> of the
irst letter following this sequence.
--------------------------------------
numkey=`def_enigma $textkey` ; start=$?
--------------------------------------

Decode the remaining text with the key:
------------------------------------------
enigma <numkey> -f<start>  < <coded_file>  > <decoded_file>
------------------------------------------

