
                          E N I G M A
                          -----------

1. Command line
---------------
Syntax: enigma <reflector_def> [ <rotor_defs>  ] [ <rotor_inits> ]
               [ <switches> ] [ <first_index> ] [ <last_index> ]

   <reflector_def> ::= <reflector_name>[@<upperletter>]
   <rotor_defs>    ::= -r{ [#]<rotor_name>@<ring_offset>[#] }
   <rotor_inits>   ::= -i{ <upperletter> }
   <switches>      ::= -s{ <upperletter><upperletter> }
   <first_index>   ::= -f<positive>       (default 1)
   <last_index>    ::= -l<positive>       (default none)
   <ring_setting>  ::= <upperletter>
   <upperletter>   ::= A .. Z
Up to 4 rotors can be used and one reflector must be defined.
They must have different names.
There must be as many rotor offsets as rotors defined.
Ex, for rotors I (fastest), IV and Beta (slowest): "Beta@A#IV@Q#I@F".

Semantic:
- The reflector is defined by its name and the optional letter of offset (constant).

- Up to 4 rotors can be defined and one reflector must be defined.
They must all have different names.
All rotors and reflectors are defined in a XML configuration file (name from
ENV ENIGMA_CONF_FILE, default "enigma.xml"). They must all have differenti
names.
Rotor carries are the offsets at which next rotor will turn together with
current. Rotors with no carry can only appear at first position (slowest) and
don't turn.
ABCDEFGHIJKLMNOPQRSTUVWXYZ
|                        |
BCDEFGHIJKLMNOPQRSTUVWXYZA
For a reflector, the definition must be symetrical and with no identity?

In the command line, the rotors (optional) definition consists in <rotor_defs>
(rotor name @ ring setting, separated by #) and <rotor_inits>, the initial
position of each rotor. First rotor defined is the slowest and is the one
crossed just before the reflector. So for command line "I IV V", the coding
will go through V, IV, I, reflector, then back.

- The switches definition follows the same logic but defines only the letters
that change in the coding (all other letters are kept unchanged). ex:
AZBJMGYC
Note that max 13 pairs can be defined, with no identity and each letter can
appear at most once (implicit symetry).

- The first_index number defines the offset of input text from which the
decoding starts (default 1).

- The last number defines the last offset of input text after which the
decoding stops (default none).

2. Behaviour
------------
Data flows:
The program reads a byte flow to code from stdin and puts the corresponding
coded flow on stdout. Uppercase letters are coded the standard enigma way (see
below). Lower letters are converted to uppercase, codded, then converted to
lowercase. Other bytes are not coded (they are put unchanged on stdout).

Turning rules and coding ways:
Rotors turn before the coding. The Enigma double stepping behaviour applies.

Coding rule:
The input letter (uppercase) is encoded through the switches, through all
the rotors, then through the refelctor (this is called encoding).
It is then encoded the other way through all the rotors and the switch (this
is called decoding). The complete cycle is called coding.

      + <------ +-----+ <- +-----+ <- +--------+ <- Input
 |Reflector|    |Rotor|    |Rotor|    |Switches|
      + ------> +-----+ -> +-----+ -> +--------+ -> Output


3. Coding algorithms and objects
--------------------------------
Letters are represented by a modulus 0 .. 25, the Id (A->0, B->1, .. Z->25).
Coding X through a rotor or through the reflector means:
- The current offset O of the rotor is nb of increments - ring setting
  and the offset O of the reflector is constant
- Input I is X + O
- Output U from I is got from the scrambler definition of the rotor
- The final result R is U - O
Decoding is similar except that I = X - O, the scrambler is inverted and then
R is U + O.

A scrambler is made of an arrays, each of 26 different Ids.

4. General Design
-----------------
The software is decomposed into the following components:
- A Definition that checks and loads the configuration file, and
initializes the machine from it.

- The Io_Manager, that reads and writes bytes. It supports
Skip (Nb_Bytes);  -- From input flow
Read -> Byte;     -- Or raises End_Error
Write (Byte);

- The Coder, that encodes uppercase characters. It supports:
Init;   -- Using the Definition to init the enigma
Encode (Upper_Char) -> Upper_Char;

- The main inits the scrambler factory then the Coder, then run the scheduler.
  Io_Manager.Skip (Nb_Bytes);  -- From the command line
  loop
    Byte := Io_Manager.Read;
    case Byte_Kind is
      when Upper_Char =>
        Byte := Coder.Encode (Byte);
      when Lower_Char =>
        Byte := Lower_Char (Coder.Encode (Upper_Char (Byte)));
      when others =>
        null;  -- Byte unchanged
    end case;
    Io_Manager.Write (Byte);
  end loop;

5. Coder design
---------------
The initialization consists in getting the definitions
make them through the factory and store them.
Encoding an upper character consists in:
- Turning the rotors (double stepping applies)
- Encoding through the switches
- Encoding through the rotors (right to left, fastest to slowest)
- Encoding through the reflector
- Decoding through the rotors (left to right, slowest to fastest)
- Encoding through the switches
- Returning the coded upper character.

6. Compatibility
----------------
Enigma can simulate Enigma M3 and M4 machines, but also allows more combinations
than the physical machines (rotors are from 0 to 4, no restriction on the
combination of first (slowest) rotor and reflector, offset of reflector...).
M3 compatible configurations shall use a reflector from A to C with no offset
and 3 rotors from I to VIII.
M4 compatible configurations shall use a reflector Bthin or Cthin with no
offset, a rotor Beta and 3 rotors from I to VIII.

