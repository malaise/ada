
                          E N I G M A
                          -----------

1. Command line
---------------
Syntax: enigma [ <switch> ] [ <jammers>  ] <back> [ <rotors> ] [ <start_index> ]
               [ <last_index>]

<switch>        ::= -s{ <upperletter><upperletter> }
<jammers>       ::= -j{ <scrambler_num><upperletter> }
<back>          ::= -b<scrambler_num><upperletter>
<rotors>        ::= -r{ <upperletter> }
<first_index>   ::= -f<positive>
<last_index>    ::= -l<positive>
<scrambler_num> ::= 1 .. 9
<upperletter>   ::= A .. Z
<positive>      ::= 1 ..

Semantic:
- Up to 8 jammers can be defined and one back must be defined.
They must all have different numbers. ex "2A1X9F".
All the scamblers are defined in a conf file (name from ENV ENIGMA_CONF_FILE,
default "enigma.cnf"). This file has the following syntax (lines starting with
# and and empty lines are skipped): Each scambler is defined by three lines.
The first line is the scambler number from 1 to 9, the second is ABCD...XYZ and
the third defines the correspondig letters. ex:
3
ABCDEFGHIJKLMNOPQRSTUVWXYZ
BCDEFGHIJKLMNOPQRSTUVWXYZA
The third line must define all the letters once and only once.
For a back, the definition must be symetrical: If X encodes to Y, then Y must
encode to X (X decodes to Y).
In the command line, a jammer definition is the scrambler number and a letter of
carry offset (which is used to increment next jammer).
- The back definition is the scrambler number and the letter of offset (constant).
- The switch definition follows the same logic but defines only the letters that
change in the coding (all other letters are kept unchanged). ex:
AZBJMGZB
Note that the same letter can appear at max twice, but always in different
part of a pairs (AXYA and AA are OK but not AXAY).
- The rotors setup definition defines (with letters), the initial position of the
jammers.
- The first_index number defines the offset of input text from which the
decoding starts (default 1).
- The last number defines the last offset of input text after which the
decoding stops (default none).

2. Behaviour
------------
Data flows:
The program reads a byte flow to code from stdin and puts the corresponding
coded flow on stdout. Uppercase letters are coded the standard enigma way (see
below). Lower letters are converted to uppercase, codded, then converted to
lowercase. Other bytes are not coded (they are put unchanged on stdout).

Turning rules and coding ways:
Before coding, the offset of the first jammer is incremented.
After a certain number of  increments of the first jammer (carry offset), the
second jammer is incremented...
All the jammers can turn and are used both ways. The back and the switch
don't turn. The jammers and the back have a (initial in case of jammer) offset.

Coding rule:
The input letter (uppercase) is encoded through the switch, through all
the jammers, then through the back (this is called encoding).
It is then encoded the other way through all the jammers and the switch (this
is called decoding). The complete cycle is called coding.

InputLetter  -> +------+ -> +------+ -> +------+ ->  +
                |Switch|    |Jammer|    |Jammer|   |Back|
OutputLetter <- +------+ <- +------+ <- +------+ <-  +


3. Coding algorithms and objects
--------------------------------
Letters are represented by a modulus 0 .. 25, the Id (A->0, B->1, .. Z->25).
Coding X through a jammer or through the back means:
- The current offset O of the jammer is the initial offset + nb of increments
- Input I is X + O
- Output O from I is got from the jammer definition. 
Decoding is similar except that I = X - O.

A scrambler is made of two arrays, each of 25 different Ids, one for encoding
one for decoding. The decoding is the reverse of the encoding.
Initialy, Encode(i) = i and Decode(i)=i.
It supports the operations:
* Set (Nid1, Nid2), that makes:
-- Save previous connection
Oid1 := Encode(Nid1);
Oid2 := Decode(Nid2);
-- Set new connection
Encode(Nid1) := Nid2;
Decode(Nid2) := Nid1;
-- Set missing connection
Encode(Oid2) := Oid1;
Decode(Oid1) := Oid2;
* Encode(x) that returns Encode(x)
* Decode(x) that returns Decode(x)

The back adds the concept of initial offset.
It supports:
* Set_Offset(Id);
* Encode(x) that returns Encode(x+Offset)-Offset   -- From the scrambler

A back is child of scrambler.

A jammer is a child of scrambler. It adds the concept of increment.
It supports:
* Set_Carry(Id);
* Increment -> Boolean; -- True after carry increments then each 26 increments
* Set_Offset(Id);
* Encode(x) that returns Encode(x+Offset)   -- From the scrambler
* Decode(x) that returns Decode(x)-Offset

4. General Design
-----------------
The software is decomposed into the following components:
- A Scrambler_Factory that loads the configuration file, creates and
initializes the scramblers from it.

- A Definition that parses the command line arguments and allows
to retrieve:
Get_Switch -> Array_Of_Pairs_Of_Ids;               -- (Id, Id)
Get_Jammers -> Array_Of_Pairs_Of_Scrambler_Offset; -- (Scrambler, Offset)
Get_Back    -> Pair_Of_Scrambler_Offset;           -- (Scrambler, Offset)

- The Io_Manager, that reads and writes bytes. It supports
Skip (Nb_Bytes);  -- From input flow
Read -> Byte;     -- Or raises End_Error
Write (Byte);

- The Coder, that encodes uppercase characters. It supports:
Init;   -- Using the Scrambler_Factory and Definition to init the enigma
Encode (Upper_Char) -> Upper_Char;

- The main inits the scrambler factory then the Coder, then run the scheduler.
  Io_Manager.Skip (Nb_Bytes);  -- From the command line
  loop
    Byte := Io_Manager.Read;
    case Byte_Kind is
      when Upper_Char =>
        Byte := Coder.Encode (Byte);
      when Lower_Char =>
        Byte := Lower_Char (Coder.Encode (Upper_Char (Byte)));
      when others =>
        null;  -- Byte unchanged
    end case;
    Io_Manager.Write (Byte);
  end loop;

5. Coder design
---------------
The initialization consists in getting the definitions of various scramblers,
make them through the factory and store them.
Encoding an upper character consists in:
- Incrementing the Jammer1, and if it circled
    Incrementing the Jammer2, and if it circled...
- Subcontracting to the scramblers: Switch.Encode,
 Jammer1.Encode ... JammerN.Encode, Back.Encode,
 JammerN.Decode .. Jammer1.Decode, Switch.Decode.
- Returning the coded upper character.

