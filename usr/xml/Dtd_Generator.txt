Dtd_Generator, elements of deisgn
=================================

General principle
-----------------
Dtd_generator parses one by one the input XML files (or stdin). It uses the
Xml_Parser in tree mode and scans the tree. +
For each elements it establishes a 'new' list of children, which it merges with
the 'previous' definition (if any), of children of this element. +
Similarly, it establishes a 'new' list of the attributes of the element and
it merges each attribute definition with any 'previous' definition of this
attribute. +
The merging strategies are described hereafter.

Children
--------

New children definition
~~~~~~~~~~~~~~~~~~~~~~~
Based on the tree generated by Xml_Parser, dtd_generator establishes a 'new'
definition of children for the current element. The definition can be of the
kind:

* Sequence : When all the children are elements, then the definition is a
Sequence that contains each child, possibly with a 'Mult' tag when the child
appears several time successively.

* Mixed : When the children are elements and text, then the definition is
mixed and contains the list of children (each appearing once).

* Pcdata : When the child is only text, then the definition is Pcdata.

* Empty : When the element has no child, then the defintion is Empty.

* Not_Empty : When the element has no child, but contains comments and/or PIs.
It cannot be Empty but can become a Sequence, Mixed...

Previous children definition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The 'previous' definition of children either:

* does not exist (when processing the first occurence of this element), then
the 'new' definition becomes the 'previous',
* already exists as an initial copy or already as the result of a merge. +
In this case the 'new' definition needs to be merged into the 'previous'. The
result can be of the kind Sequence, Mixed, Pcdata or Empty, like a 'new'
defintion, but also of the kind:

* Choice: When all the children are elements but lead to a sequence that is
too complex, then the sequence is replaced by a choice, where each child
appears optionally and only once, like a Mixed but wihtout PCdata:
('(Elt|Elt|....)*').

* Any: When the children are too many, then the definition is replaced by a
Any.

Also, in case of Sequence, the definition of each child can have the tag 'Opt'
(that completes the tag 'Mult') to indicate an optional child.

Merging children definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.Merging two sequences
The case when both definitions are sequences is the most complex and is
detailed in the next section.

.Merging two definitions of same kind
When both definitions are of the same kind (but not sequences), the result
is of this kind and the list, af any, is reduced so that it contains each
element only once.

.Merging two definitions of different kinds
The result of such merge become the less stringent of both
definitions and takes into account both constraints. Examples:

* a Sequence and a Choice becomes a Choice (with lists merged)
* a Sequence and a Mixed or Pcdata becomes a Mixed (with lists merged)
* a Sequence and an Empty becomes a Sequence with all children optional
* a Choice and a Pcdata becomes a Mixed 
* any kind and an Any becomes an Any +
...

NOTE: Each change of a list (Sequence, Choice or Mixed) that leads to exceed
the maximum number of elements (if set) leads the list to be replaced by an
Any.

NOTE: Each change in a Sequence increases by 1 the deviation. If the deviation
of a Sequence exceeds the maximum deviation allowed (if set) then the Sequence
is replaced by a Choice.

Merging sequences
~~~~~~~~~~~~~~~~~
The merging of two sequences explores all the combinations and identifies the
solution that leads to the minimum deviation. This can be costly, which is why
two alternate strategies are identified.

.Optimisation
If both sequences have the same children in the same order, then the
merge only consists in propagating the 'Mult' tags of the 'new' sequence into
the 'previous' one (remember that the 'new' sequence cannot have tags 'Opt').

.Simplification
If either the 'new' or the 'current' sequence length is above the maximum
deviation allowed (if set), then a more simple mode of exploration is defined
(see below).

.Exploration
The exploration algorithm does not depend on the 'Mult' tags but considers
the 'Opt' tags of the 'previous' sequence. Let's take an example, where A,
B... are child names and \'o' indicates an optional child.

 new:     A  B  E  G
 current: A  B  C  Do E

At each step, the algorithm has an index in the 'new' and in the 'current'
sequence and it compares the content.

* If both are the same, then it is possible to step in both lists, which
decreases the deviation by 1.

* Alternatively if the current 'current' is optional, then it can be skipped
with no deviation. If it is no optional, then it can be changed as optional
with a deviation increase of 1.

* Alternatively, the current 'new' can be changed as optional and inserted,
before the current 'current', with a deviation increase of 2.

The algorithm builds the whole tree of all the combinations, except that:

* If the simple mode has been activated (too long sequences), and when a
step of both children is possible, then the two other options are not
explored.

* When the maximum deviation allowed is reached (if set), then the current
solution is abandonned and the scan continues.

The tree keeps track of the cumulated deviation optained to build each node and
also remembers the best deviation ever obtained.

Then the best branch is identified and the modifications are applied to the
'current' sequence.

Attributes
----------

New attribute definition
~~~~~~~~~~~~~~~~~~~~~~~~
The new attribute definition

Previous attribute definition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The previous attribute definition

Merging attribute definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Merging
