Dtd_Generator, elements of design
=================================

General principle
-----------------
Dtd_generator parses one by one the input XML files (or stdin). It uses the
Xml_Parser in tree mode and scans the tree. +
For each elements it establishes a 'new' list of children, which it merges with
the 'previous' definition (if any), of children of this element. +
Similarly, it establishes a 'new' list of the attributes of the element and
it merges each attribute definition with any 'previous' definition of this
attribute for this element. +
The merging strategies are described hereafter.

Children
--------

New children definition
~~~~~~~~~~~~~~~~~~~~~~~
Based on the tree generated by Xml_Parser, dtd_generator establishes a 'new'
definition of children for the current element. This definition can be of the
kind:

* Sequence : when all the children are elements. The Sequence contains each
child, possibly with a 'Mult' tag when the child appears several times
successively.
* Mixed : when the children are elements and text. The Mixed definition
contains the list of children (each appearing once).
* Pcdata : when the child is only text.
* Empty : when the element has no child at all.
* Not_Empty : when the element has no child but contains comments and/or PIs.
It cannot be Empty but can become a Sequence, Mixed...

Previous children definition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The 'previous' definition of children is the merged result of the previous
definitions found so far. It can either be:

* not exist (when processing the first occurence of this element), then
the 'new' definition becomes the 'previous',
* already exists as an initial copy or already as the result of a merge. +
In this case the 'new' definition needs to be merged into the 'previous'. +
The result can be of the kind Sequence, Mixed, Pcdata or Empty, like in a 'new'
defintion, but also of the kind:
 - Choice: When all the children are elements but lead to a sequence that is
too complex, then the sequence is replaced by a choice, where each child
appears optionally and only once, ('(Elt|Elt|....)*'). So this is like a Mixed
but wihtout PCdata.
 - Any: When the children are too many, then the definition is replaced by a
Any.

Also, in case of Sequence, the 'previous' definition of each child can have the
tag 'Opt' (that completes the tag 'Mult') in order to indicate an optional
child.

Merging children definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.Merging two sequences
The case when both definitions are sequences is the most complex and is
detailed in the next section, xref:XMergeSeq[mergin sequences].

.Merging two definitions of same kind
When both definitions are of the same kind (but not sequences), the result
is of this same kind and the list, af any, is reduced so that it contains each
element only once.

.Merging two definitions of different kinds
The result of such merge become the less stringent of both
definitions and takes into account both constraints. Examples:

* a Sequence and a Choice becomes a Choice (with lists merged)
* a Sequence and a Mixed or Pcdata becomes a Mixed (with lists merged)
* a Sequence and an Empty becomes a Sequence with all children optional
* a Choice and a Pcdata becomes a Mixed 
* any kind and an Any becomes an Any +
...

NOTE: Each change of a list (Sequence, Choice or Mixed) that leads to exceed
the maximum number of elements (if set) leads the list to be replaced by an
Any.

NOTE: Each change in a Sequence increases by 1 the deviation. If the deviation
of a Sequence exceeds the maximum deviation allowed (if set) then the Sequence
is replaced by a Choice.

Merging sequences
~~~~~~~~~~~~~~~~~
anchor:XMergeSeq[]
The merging of two sequences explores all the combinations and identifies the
solution that leads to the minimum deviation.

.Optimisation
If both sequences have the same children in the same order, then the
merge only consists in propagating the 'Mult' tags of the 'new' sequence into
the 'previous' one (remember that the 'new' sequence deos not have tags 'Opt').

.Exploration
The exploration algorithm does not depend on the 'Mult' tags but considers
the 'Opt' tags of the 'previous' sequence. Let's take an example, where A,
B... are child names and \'o' indicates an optional child.

          |
 new:     A  B  E  G
 current: A  B  C  Do E
          |

At each step, the algorithm has an index in the 'new' and in the 'current'
sequence and it compares the content.

* If both are the same, then it is possible to step in both lists, which
decreases the deviation by 1 and prevents exploring the other alternatives. +
In our example, two steps are initially possible and will lead to:

                |
 new:     A  B  E  G
 current: A  B  C  Do E
                |

* Alternatively, if the current 'current' is optional, then it can be skipped
with no deviation. If it is not optional, then it can be changed as optional
with a deviation increase of 1. +
In our example, and after the two initial steps, this will lead to:

                   |
 new:     A  B  Eo G
 current: A  B  C  Do E
                |


* Alternatively, the current 'new' can be changed as optional and inserted,
before the current 'current', with a deviation increase of 2. +
In our example, and after the two initial steps, this will lead to:

                   |
 new:     A  B  Co E  G
 current: A  B  C  Do E
                   |

The algorithm builds the whole tree of all the combinations, except that:

* when a step of both children is possible, then the two other options are not
explored,

* when the maximum deviation allowed (if set) is reached, then the current
solution is abandonned and the exploration continues.

The tree keeps track of the cumulated deviation optained to build each node and
also remembers the best deviation ever obtained.

Then the tree in scanned in order to identify the (first) branch that leads
to this best deviation.

Then the content of this branch (list of modifications) is applied to the
'current' sequence.

NOTE: The algorithm checks that the maximum number of elements (if set) is not
exceeded, otherwise it generates an Any. It also checks that the overall
deviation (if set) is not exceeded, otherwise it generates leads to a Choice.

Attributes
----------

Attribute definition of a new element
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Each attribute occuring for a given element is typed according to its value,
from the most to the less stringent criteria:

* Enum: the value follows the XML 'name' production rule. The value is stored in
a list of possible values for the enum.

* Nmtoken: otherwise the value follows the XML 'nmtoken' production rule,

* Nmtokens: otherwise the value follows the XML 'nmtokens' production rule,

* Cdata: the value does not follow any of these rules.

The first occurence of an element leads to the definitions of all its
attributes as Required.

Attribute definition of an element already known
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The 'previous' definition of an attribute has the same possible kinds as a
a 'new' definition.

Merging attribute definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When there is no previous occurence of an attribute for an element that
already exists, then this attribute is added as Implied. +
Similarly, if an already known attribute does not appear in a new occurence of
an element, then the attribute is changed as Implied.

Merging of attributes follows the same logic as children: the result is the
less stringent of the 'new' and the 'previous' definitions.

In case of both Enums, the 'new' definition may introduce a new value, which is
appended to the list of possible values. If this list becomes longer than the maximum
number of enums (if set) then the Enum becomes a Nmtoken.

Result
------

The parsing of the files and the merging of all the elements leads to a hashed
list where each element appears once and contains the list of its children and
attributes.

This list is scanned in order to generate the proper \'!<ELEMENT' and
\'<!ATTLIST' directives of the DTD.



