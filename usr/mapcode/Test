#!/bin/bash

if [ "$1" = "-d" ] ; then
  export DEBUG="-d"
fi

# Read field $3 of line $2 of file $1
function readarg {
res="`awk -vLINE=$2 -vFIELD=$3 '
  BEGIN {
    NL=0
  }
  (NF == 0 || $1 ~ /^#/) {
    # Skip empty lines and comment
    next
  }
  {
    # Count significant lines
    NL=NL+1
    if (NL == LINE) {
      printf "%s",$FIELD
      exit 0
    }
  } 
' $1`"
echo "$res"
}

# Check that $1 = $2
# Compare floats modulo EPS (1.0E-4)
function check {
  echo $1 | awk -v EXPECT="$2" '
  BEGIN {EPS=1.0E-4}
  {
    NEXPECT=split(EXPECT, EXPECTS)
    NOUTPUT=split($0, OUPUTS);
    if (NEXPECT != NOUTPUT) {print "1"; exit}
    for (I = 0; I < NEXPECT; I++) {
      if ( (EXPECTS[i] > OUTPUTS[I] + EPS) \
        || (EXPECTS[i] < OUTPUTS[I] - EPS) ) {
        print "1";
        exit
      }
    }
    print "0"
  }
  '
}

# Play Scenario.txt
echo Scenario:
./player $DEBUG Scenario.txt
if [ $? -ne 0 ] ; then
  exit 1
fi

# Check Territory failures
echo Failure on territory decode:
# Info on  $1 in context $2 shall lead to error (exit 1)
function territory_failure {
  if [ -n "$DEBUG" ] ; then
    echo -t "$1" "$2"
  fi
  t_mapcode -t "$1" "$2" > /dev/null 2>&1
  res=$?
  if [ $res -ne 1 ] ; then
    echo "ERROR: t_mapcode -t \"$1\" "$2" has exited with code $res i.o. 1" 1>&2
    exit 1
  fi
}
territory_failure ""
territory_failure " "
territory_failure USA " "
territory_failure " " "US "
territory_failure "Toto"
territory_failure AL Toto
# For each line
let L=1
while true ; do
  ctx=`readarg TerritoryFailures.txt $L 1`
  if [ -z "$ctx" ] ; then
    break;
  fi
  ter=`readarg TerritoryFailures.txt $L 2`
  if [ -z "$ter" ] ; then
    ter=$ctx
    ctx=""
  fi
  territory_failure $ter $ctx
  let L=$L+1
done
echo OK.

# Check decoding failures
echo Failure to decode:
# Decoding $1 in context $2 shall lead to error (exit 1)
function decode_failure {
  if [ -n "$DEBUG" ] ; then
    echo -d "$1" "$2"
  fi
  t_mapcode -d "$1" $2 > /dev/null 2>&1
  res=$?
  if [ $res -ne 1 ] ; then
    echo "ERROR: t_mapcode -d \"$1\" $2 has exited with code $res i.o. 1" 1>&2
    exit 1
  fi
}
decode_failure ""
# For each line
let L=1
while true ; do
  ctx=`readarg DecodeFailures.txt $L 1`
  if [ -z "$ctx" ] ; then
    break;
  fi
  cod=`readarg DecodeFailures.txt $L 2`
  if [ -z "$cod" ] ; then
    cod=$ctx
    ctx=""
  fi
  decode_failure $cod $ctx
  let L=$L+1
done
echo OK.

# Encode then decode
echo Encode then decode:
# For each line
let L=1
while true ; do
  # Read lat and lon
  lat=`readarg EncodeOk.txt $L 1`
  if [ -z "$lat" ] ; then
    break;
  fi
  lon=`readarg EncodeOk.txt $L 2`
  # Encode
  result=`t_mapcode -c $lat $lon`
  if [ $? -ne 0 ] ; then
    echo "ERROR: t_mapcode -t $lat $lon has failed." 2>&1
    exit 1
  fi
  # Parse result:
  # lat lon => Short Code, then either 'Code Short' or Long, then num
  result=`echo $result | awk '
    (substr($6, 1, 1) == "'\''") {
      print substr($6,2) " " substr($7, 1, length($7)-1)
      exit
    }
    {
      print $6
    }
  '`
  ctx=`echo $result | awk '{print $1}'`
  cod=`echo $result | awk '{print $2}'`
  if [ -z "$cod" ] ; then
    cod=$ctx
    ctx=""
  fi
  # Decode
  decoded=`t_mapcode -d $cod $ctx | cut -d ' ' -f 2-`
  if [ $? -ne 0 ] ; then
    echo "ERROR: t_mapcode -d $cod $ctx has failed." 2>&1
    exit 1
  fi
  res=`check "$decoded" "$lat $lon"`
  # Check decoded lat lon versus origin
  if [ "$res" != "0" ] ; then
    echo "ERROR: $lat $lon => $result => $decoded" 2>&1
    exit 1
  else
    if [ -n "$DEBUG" ] ; then
      echo "$lat $lon => $result => $decoded"
    fi
  fi

  let L=$L+1
done
echo OK.

# Decode
echo Decode:

# Count line ("=>") of output
function count {
  echo "$*" | awk '
    BEGIN {FS="=>"}
    {print NF - 1}
  '
}

# Decoding mapcode $1 in context $2 shall lead $3 and $4
# Ecoding lat lon $3 and $4 in context $2 shall lead to $5 mapcodes
# Ecoding lat lon $3 and $4 without context $2 shall lead to $6 mapcodes
function decode {
  if [ -n "$DEBUG" ] ; then
    echo -d "$1" "$2"
  fi
  result=`t_mapcode -d "$1" $2`
  res=`check "$3 $4" "$result"`
  if [ $res -ne 1 ] ; then
    echo "ERROR: t_mapcode -d $1 $2 => $result instead of $3 $4" 2>&1
    exit 1
  fi
  # Count number of all local codes
  res=`t_mapcode -c $3 $4 $2 False`
  let nloc=0+`count $res`
  if [ $nloc -ne $5 ] ; then
    echo "ERROR: t_mapcode -c $3 $4 $2 False => $nloc results instead of $5" 2>&1
    exit 1
  fi
  # Count number of all global codes
  res=`t_mapcode -c $3 $4 False`
  let nloc=0+`count $res`
  if [ $nloc -ne $6 ] ; then
    echo "ERROR: t_mapcode -c $3 $4 False => $nloc results instead of $6" 2>&1
    exit 1
  fi
}
# Theses one have no context
decode "ZH0H0.H1HG" ""    "90" "0" 1 1
decode "ZZ0X0.B16G-4K" "" "90" "179" 1 1
decode "Z0000.010G"    "" "90" "-179.999999" 1 1
decode "ZZ0Z0.Z1YG"    "" "90.000000000000" "179.999999999999" 1 1

# Play scenario
# For each line
# Read ctx cod lat lon loc glo
let L=0
while read -r ctx cod lat lon loc glo || [[ -n "$ctx" ]]; do
  if [ \( -z "$ctx" \) -o \( "$ctx" = "#" \) ] ; then
    continue
  fi
  decode $cod $ctx $lat $lon $loc $glo

  R=$((L % 100))
  if [ $R -eq 0 ] ; then
    echo -n "."
  fi
  let L=$L+1
done < DecodeOk.txt
echo
echo OK.
