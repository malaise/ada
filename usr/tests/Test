#!/bin/bash

# Automatic tests of tests

# Cleanup
function clean {
  rm -f out out? err err? exp exp? tmp tmp? nul
}

trap clean SIGINT SIGTERM

# Error message
function error {
  echo
  echo $* 2>&1
  exit 1
}

# Function to launch an interactive test
function launch {
  echo "Sarting $1:"
  $* 
  echo "$1 Done."
}


# Interactive tests
if [ "$1" = "-i" ] ; then
  launch t_arbitrary
  launch t_control_pool
  launch t_dur_image
  launch t_color
  launch t_con > /dev/null
  launch t_afpx
  launch t_curve
  launch t_dscr
  clean
  echo "Done."
  exit
fi

# Utilities for automatic tests
echo -n > nul

# Title
function title {
  echo -n $* ": "
}

# Launch a test 
function try {
  local ok=1
  if [ $1 = "-n" ] ; then
    ok=0
    shift
  fi
  $* > out 2> err
  res=$?
  if [ $ok -eq 1 ] ; then
    if [ $res -ne 0 ] ; then
      error "Test $1 has failed."
    fi
  else
    if [ $res -eq 0 ] ; then
      error "Test $1 should have failed."
    fi
  fi
}

# Compare 2 files
function comp {
  local ok=1
  if [ $1 = "-n" ] ; then
    ok=0
    shift
  fi
  cmp $1 $2 2> /dev/null
  res=$?
  if [ $ok -eq 1 ] ; then
    if [ $res -ne 0 ] ; then
      error "File $1 differs from expected $2."
    fi
  else
    if [ $res -eq 0 ] ; then
      error "File $1 should differs from expected $2."
    fi
  fi
}

# skip some tests
if [ "$1" != "-t" ] ; then

# t_ada_parser
title t_ada_parser
export INPUT=t_ada_parser.adb
try t_ada_parser $INPUT
comp out $INPUT
NB=`wc -l err | awk '{print $1}'`
export ENB=712
if [ $NB -ne $ENB ] ; then
  error "File err has incorrect length $NB i.o. $ENB."
fi
echo "OK"

# t_arbitrary
title t_arbitrary
try t_arbitrary 21
cat > exp << EOF
A is        +21
abs A is    +21
-A is       -21
A positive  True
Sqrt(A)     +4
Digits:  2 and 1
EOF
comp out exp
comp err nul

try t_arbitrary 3 7
cat > exp << EOF
A is        +3
abs A is    +3
-A is       -3
A positive  True
Sqrt(A)     +1
Digits:  and 3

B is        +7
abs B is    +7
-B is       -7
B positive  True
Sqrt(B)     +2 remaining +3
A =  B is   FALSE
A <  B is   TRUE
A <= B is   TRUE
A >  B is   FALSE
A >= B is   FALSE
A + B is   +10
A - B is   -4
A * B is   +21
A / B is   +0
A % B is   +3
A rem B is +3
A mod B is +3
A ** B is  +2187
EOF
comp out exp
comp err nul
echo "OK"

# t_arg
title t_arg
echo -e "K\na1\n1\nY\n2\nA\n1\nE" | try t_arg -a1v1 -a2
cat > exp << EOF
>< >t_arg<
 2 arguments.
E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter KEY ? Enter OCCURENCE ? Argument : >v1<
Char ->v<  118
Char ->1<  49
 found at position   1

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter OCCURENCE ? Argument : >a2<
Char ->a<  97
Char ->2<  50
 found at position   2

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter OCCURENCE ? Argument : >-a1v1<
Char ->-<  45
Char ->a<  97
Char ->1<  49
Char ->v<  118
Char ->1<  49
 found at position   1

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : 
EOF
comp out exp
comp err nul
echo "OK"

# t_arg_parser
title t_ada_parser
try t_arg_parser auto

try t_arg_parser -f -m  -m no -o -c -t -c 2
cat > exp << EOF
Parsing OK is TRUE and parsing error string is >OK.<
Number of keys found: 7, Last key at pos: 8, First after at pos: 0 and Nb embedded arguments: 1
Arguments not key are found on 1 occurences.
  Kind: Str  Position:  4  Option >no<
Key f first is found on 1 occurences.
  Kind: Chr  Position:  1  Option ><
Key s second is found on 0 occurences.
Key t third is found on 1 occurences.
  Kind: Chr  Position:  7  Option ><
Key m multi is found on 2 occurences.
  Kind: Chr  Position:  2  Option ><
  Kind: Chr  Position:  3  Option ><
Key o opt is found on 1 occurences.
  Kind: Chr  Position:  5  Option ><
Key c combine is found on 2 occurences.
  Kind: Chr  Position:  6  Option ><
  Kind: Chr  Position:  8  Option >2<
EOF
comp out exp
comp err nul
echo "OK"

# t_asb and t_asu
title t_asb and t_asu
try t_asb
mv out out1
comp err nul

try t_asu
comp err nul
comp out out1
echo "OK"

# t_assert
title t_assert
cat > exp << EOF
This program is normally silent
Set ENV variable ASSERT_ACTION to TRACE to see the 3 traces
 or to RAISE to raise first exception.
EOF
try t_assert
comp out exp
comp err nul
export ASSERT_ACTION=TRACE

try t_assert
comp out exp
comp -n err nul
export ASSERT_ACTION=RAISE

try -n t_assert
comp out exp
comp -n err nul
echo "OK"

# t_async
title t_async
xterm -e "t_async -s 20000 > out 2> err" &
export PID=$!
sleep 0.7
expect \
-c 'spawn telnet localhost 20000; \
  set timeout 1; \
  expect "Nothing"
  send "Toto\n"; \
  sleep 0.3; \
  close' > /dev/null
kill $PID
cat > exp << EOF
Toto
EOF
comp out exp
cat > exp << EOF
connected
disconnected
EOF
comp err exp
echo "OK"

# Skip some tests

# t_autobus
title t_autobus
t_autobus -a > out1 2> err1 &
export PID=$!
sleep 0.7
try t_autobus -a Ah que coucou
kill $PID
cat << EOF > exp
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Spyed >Coucou!<
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Spyed >Coucou!<
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Spyed >Coucou!<
Closing.
Done.
EOF
comp out1 exp
comp err1 nul
comp err nul
echo "OK"

# t_basic
title t_basic
echo -e "toto\ntiti" | t_basic > out 2> err
cat << EOF > exp
toto
titi
EOF
cat << EOF > exp1
End_Error
EOF
comp out exp
comp err exp1
echo "OK"

# t_basic
title t_bloc_io
try t_bloc_io
tail -3 out > tmp
cat << EOF > exp
Dump:  42 
Set index to  5371
Dump:  21 -1 -2  21 
EOF
comp tmp exp
comp err nul
echo "OK"

# t_byte_to_unicode
title t_byte_to_unicode
try t_byte_to_unicode data/ISO-8859-9.xml
grep -E "^222" out > out1
tail -2 out > out2
cat << EOF > exp1
222      16#DE# ->   350     16#15E#
EOF
cat << EOF > exp2
255      16#FF# ->   255      16#FF#

EOF
comp out1 exp1
comp out2 exp2
comp err nul
echo "OK"

# t_c_nbres
title t_c_nbres
try t_c_nbres 1 5 3 -2
cat << EOF > exp
Got:  1.00000000000000E+00 + i * 5.00000000000000E+00
 in polar:  5.09901951359278E+00  1.37340076694502E+00rd  7.86900680000000E+01Â°
Got:  3.00000000000000E+00 - i * 2.00000000000000E+00
 A+B:  4.00000000000000E+00 + i * 3.00000000000000E+00
 A-B: -2.00000000000000E+00 + i * 7.00000000000000E+00
 A*B:  1.30000000000000E+01 + i * 1.30000000000000E+01
 A/B: -5.38461538461538E-01 + i * 1.30769230769231E+00
 A**B.real: -7.40000000000000E+01 - i * 1.10000000000000E+02
EOF
comp out exp
comp err nul
echo "OK"

# t_command
title t_command
try t_command -s /bin/ls t_c*
cat << EOF > exp
Output flow:
>t_channels<
>t_channels.adb<
>t_c_nbres<
>t_c_nbres.adb<
>t_color<
>t_color.adb<
>t_command<
>t_command.adb<
>t_computer<
>t_computer.adb<
>t_con<
>t_con.adb<
>t_cond<
>t_cond.adb<
>t_control_pool<
>t_control_pool.adb<
>t_conv<
>t_conv.adb<
>t_curve<
>t_curve.adb<

Error flow:
><

Exit code:  0
EOF
comp out exp
comp err nul
echo "OK"

# t_computer
title t_computer
try t_computer "V1=5" "V2=2" '3*(${V1}+${V2})'
cat << EOF > exp
Evaluation: 
3*(5+2)
Computation: 
 21
EOF
comp out exp
comp err nul
echo "OK"

# t_cond
title t_cond...
try t_cond
comp err nul
echo "OK"

# t_conv
title t_conv
try t_conv
cat << EOF > exp
Host:       16#12345678#
to Network: 16#78563412#
to Host:    16#12345678#
EOF
comp out exp
comp err nul
echo "OK"

# t_day_mng
title t_day_mng
echo  -e "5\n600\n57000\n" | try t_day_mng 
echo >> out
cat << EOF > exp
Enter a duration:  5.000000000
 0 h   0 min   5 sec   0 msec

Enter a duration:  600.000000000
 0 h   10 min   0 sec   0 msec

Enter a duration:  57000.000000000
 15 h   50 min   0 sec   0 msec

Enter a duration: 
EOF
comp out exp
comp err nul
echo "OK"

# t_dd
title t_dd
try t_dd 10000
cat << EOF > exp
This test succeeds if no STORAGE_ERROR is raised.
Performinig  10000 iterations, each of them consisting in
 allocating  256 objects of  1024 bytes then freeing them.
Test successful.
EOF
comp out exp
comp err nul
echo "OK"

# t_delta_date
title t_delta_date
try t_delta_date 2012-07-02T15:47:12.514 1963-10-25T21:21:21.210
cat << EOF > exp
2012/07/02 15:47:12.514 is a MONDAY
1963/10/25 21:21:21.210 is a FRIDAY
 Date1 - Date2:      17782 days  66351.304000000 sec
EOF
comp out exp
comp err nul
echo "OK"

# t_dirname
title t_dirname
try t_dirname
cat << EOF > exp
Dirname /tools/toto.ads: /tools/
Dirname toto.ads: 
Dirname /toto.ads: /
Basename /tools/toto.ads: toto.ads
Basename toto.ads: toto.ads
Basename /toto.ads: toto.ads
Basename /tools/toto.ads .ads: toto
Basename /tools/toto.a .ad: toto.a
File_Prefix /tools/toto.ads: toto
File_Suffix /tools/toto.ads: .ads
Normalize /root/dir1/../dirok/./dir3/../toto.ads: /root/dirok/toto.ads
Make_Full "": /home/malaise/ada/usr/tests/
Make_Full ".": /home/malaise/ada/usr/tests/
Make_Full dir1/../dirok/./dir3/../toto.ads: /home/malaise/ada/usr/tests/dirok/toto.ads
EOF
comp out exp
comp err nul
echo "OK"

# t_dl
title t_dl
try t_dl --auto
cat << EOF > exp
Adds 10 elements
Reads 5 elements from the last one: 10 09 08 07 06 
List length: 10 
Deletes the current
Pos from first: 05 List length: 09 
Reads 7 elements from the first one: 01 02 03 04 06 07 08 
Adds the element 50 before current position
Store current access and read: 50 
List length: 10 
Reads 9 elements from the last one: 10 09 50 08 07 06 04 03 02 
Search stored access and read: 50 
Permute 1st and 4th elements, then search 3 from last
Get current pos from first: 03  Get current item: 03 
List (length: 09 ) : 04 02 01 06 07 08 50 09 10 
Seach 50 from first
Seach 50, skipping current
Returns not Found, OK
Pos from first: 07 Pos from last: 03 Can go to next: TRUE Current item, go to next: 50 
Pos from first: 08 Pos from last: 02 Can go to next: TRUE Current item, go to next: 09 
Pos from first: 09 Pos from last: 01 Can go to next: FALSE Current item, go to next: raises Not_In_List, OK
Pos from first: 09 Pos from last: 01 Current item, stay: 10 
Current item, stay: 10 
Iteration
04  is odd
02  is odd
01  is even
06  is odd
07  is even
08  is odd
50  is odd and stopping iteration
Read raises In_Callback, OK
Delete fully the list
Get current pos from first: raises Empty_List, OK
List length: 00 
Sort the list: 30 50 42 35: 30 35 42 50 
Make the following automatic list: 21 05 30 31 07 21 23 12 
After sorting it: 05 07 12 21 21 23 30 31 
Copied/Inserted in a new list between 21 and 12: 21 05 07 12 21 21 23 30 31 12 
EOF
comp out exp
comp err nul
echo "OK"

# t_door
title t_door...
try t_door
comp err nul
echo "OK"

# t_fifo
title t_fifo
try t_fifo
cat << EOF > exp
Fifo size is  5
Push  1
Look  1 -->  1
Look done
Push  2
Look  1 -->  2
Look  2 -->  1
Look done
Push  3
Look  1 -->  3
Look  2 -->  2
Look  3 -->  1
Look done
Push  4
Look  1 -->  4
Look  2 -->  3
Look  3 -->  2
Look  4 -->  1
Look done
Push  5
Look  1 -->  5
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  6
FIFO full. Discard last then push again
Look  1 -->  6
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  7
FIFO full. Discard last then push again
Look  1 -->  7
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  8
FIFO full. Discard last then push again
Look  1 -->  8
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  9
FIFO full. Discard last then push again
Look  1 -->  9
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  10
FIFO full. Discard last then push again
Look  1 -->  10
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1

Pop ==>  1
Look  1 -->  10
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look done

Pop ==>  2
Look  1 -->  10
Look  2 -->  4
Look  3 -->  3
Look done

Pop ==>  3
Look  1 -->  10
Look  2 -->  4
Look done

Pop ==>  4
Look  1 -->  10
Look done

Pop ==>  10
FIFO empty
EOF
comp out exp
comp err nul
echo "OK"

# t_file_hash
title t_file_hash
try t_file_hash t_file_hash.adb begin
cat << EOF > exp
begin -> 
FOUND begin
EOF
comp out exp
comp err nul

try t_file_hash t_file_hash.adb procedure
cat << EOF > exp
procedure -> 
NOT FOUND
EOF
comp out exp
comp err nul
echo "OK"

# t_fork
title t_fork
try t_fork /bin/ls
comp err nul

try -n t_fork /bin/lsd
cat << EOF > exp
Child mutation has failed!
EOF
comp err exp
echo "OK"

# t_fraction
title t_fraction
try t_fraction 1:3 1:6
cat << EOF > exp
A is        +1:3
abs A is    +1:3
-A is       -1:3
B is        +1:6
abs B is    +1:6
-B is       -1:6
A =  B is   FALSE
A <  B is   FALSE
A <= B is   FALSE
A >  B is   TRUE
A >= B is   TRUE
A + B is   +1:2
A - B is   +1:6
A * B is   +1:18
A / B is   +2:1
A ** B.Num is +1:3
Set (1,0) raises Constraint_Error, OK.
EOF
comp out exp
comp err nul
echo "OK"

# t_getenv
title t_getenv
unset GETENV
try -n t_getenv
cat << EOF > exp
GETENV Not set
EOF
tail -1 out > tmp
comp tmp exp
comp err nul
echo "OK"

export GETENV="test is OK."
try t_getenv
cat << EOF > exp
GETENV ->test is OK.<
EOF
tail -1 out > tmp
comp tmp exp
comp err nul
echo "OK"

# t_get_line
title t_get_line
try t_get_line t_get_line.adb
cat << EOF > exp
003 ->   5:>with<>Argument,<>Get_Line,<>Normal,<>Basic_Proc;<
004 ->   3:>procedure<>T_Get_Line<>is<
006 ->   1:>begin<
008 ->   5:>if<>Argument.Get_Nbre_Arg<>/=<>1<>then<
009 ->   6:>Basic_Proc.Put_Line_Output<>("ERROR.<>Syntax<>:<>t_get_line<><file_name>");<
010 ->   1:>return;<
011 ->   2:>end<>if;<
013 ->   1:>declare<
014 ->   6:>package<>My_Get_Line<>is<>new<>Get_Line<>("--");<
016 ->   1:>begin<
019 ->   1:>begin<
020 ->   2:>My_Get_Line.Open<>(Argument.Get_Parameter);<
021 ->   1:>exception<
022 ->   3:>when<>others<>=><
023 ->   5:>Basic_Proc.Put_Line_Output<>("ERROR<>opening<>file<>"<
024 ->   4:>&<>Argument.Get_Parameter<>&<>".");<
025 ->   1:>raise;<
026 ->   1:>end;<
029 ->   1:>loop<
030 ->   5:>Basic_Proc.Put_Output<>(Normal<>(Integer<>(My_Get_Line.Get_Line_No),<>3,<
031 ->   7:>Gap<>=><>'0')<>&<>"<>-><>");<
032 ->   6:>Basic_Proc.Put_Output<>(Normal<>(My_Get_Line.Get_Word_Number,<>3)<>&<>":");<
033 ->   1:>declare<
034 ->   6:>Line<>:<>constant<>My_Get_Line.Line_Array<>:=<>My_Get_Line.Get_Words;<
035 ->   1:>begin<
036 ->   7:>for<>I<>in<>1<>..<>My_Get_Line.Get_Word_Number<>loop<
037 ->   6:>Basic_Proc.Put_Output<>(">"<>&<>Line(I).Image<>&<>"<");<
038 ->   2:>end<>loop;<
039 ->   1:>end;<
040 ->   1:>Basic_Proc.New_Line_Output;<
041 ->   1:>My_Get_Line.Read_Next_Line;<
042 ->   2:>end<>loop;<
044 ->   1:>exception<
045 ->   3:>when<>My_Get_Line.End_Error<>=><
046 ->   1:>My_Get_Line.Close;<
047 ->   2:>Basic_Proc.Put_Line_Output<>("Done.");<
048 ->   1:>end;<
050 ->   2:>end<>T_Get_Line;<
Done.
EOF
comp out exp
comp err nul
echo "OK"

# t_init_manager
title t_init_manager...
try t_init_manager
comp err nul
echo "OK"

fi

# t_input_buffer
title t_input_buffer
try t_input_buffer t_input_buffer.adb
comp out t_input_buffer.adb
comp err nul
echo "OK"

clean
echo "Done."

