#!/bin/bash

# Automatic tests of tests

# Cleanup
function clean {
  rm -f out out? err err? exp exp? tmp tmp? nul
}

trap clean SIGINT SIGTERM

# Error message
function error {
  echo
  echo $* 2>&1
  exit 1
}

# Function to launch an interactive test
function launch {
  echo "$1"
  $* 
  echo "$1 Done."
}


# Interactive tests
if [ "$1" = "-i" ] ; then
  launch t_arbitrary
  launch t_control_pool
  launch t_color
  launch t_con > /dev/null
  launch t_afpx
  launch t_curve
  clean
  echo "Done."
  exit
fi

# Utilities for automatic tests
echo -n > nul

# Title
function title {
  echo -n $* ": "
}

# Launch a test 
function try {
  local ok=1
  if [ $1 = "-n" ] ; then
    ok=0
    shift
  fi
  $* > out 2> err
  res=$?
  if [ $ok -eq 1 ] ; then
    if [ $res -ne 0 ] ; then
      error "Test $1 has failed."
    fi
  else
    if [ $res -eq 0 ] ; then
      error "Test $1 should have failed."
    fi
  fi
}

# Compare 2 files
function comp {
  local ok=1
  if [ $1 = "-n" ] ; then
    ok=0
    shift
  fi
  cmp $1 $2 2> /dev/null
  res=$?
  if [ $ok -eq 1 ] ; then
    if [ $res -ne 0 ] ; then
      error "File $1 differs from expected $2."
    fi
  else
    if [ $res -eq 0 ] ; then
      error "File $1 should differs from expected $2."
    fi
  fi
}

# skip some tests
if [ 1 -eq 0 ] ; then

# t_ada_parser
title t_ada_parser
export INPUT=t_ada_parser.adb
try t_ada_parser $INPUT
comp out $INPUT
NB=`wc -l err | awk '{print $1}'`
export ENB=712
if [ $NB -ne $ENB ] ; then
  error "File err has incorrect length $NB i.o. $ENB."
fi
echo "OK"

# t_arbitrary
title t_arbitrary
try t_arbitrary 21
cat > exp << EOF
A is        +21
abs A is    +21
-A is       -21
A positive  True
Sqrt(A)     +4
Digits:  2 and 1
EOF
comp out exp
comp err nul

try t_arbitrary 3 7
cat > exp << EOF
A is        +3
abs A is    +3
-A is       -3
A positive  True
Sqrt(A)     +1
Digits:  and 3

B is        +7
abs B is    +7
-B is       -7
B positive  True
Sqrt(B)     +2 remaining +3
A =  B is   FALSE
A <  B is   TRUE
A <= B is   TRUE
A >  B is   FALSE
A >= B is   FALSE
A + B is   +10
A - B is   -4
A * B is   +21
A / B is   +0
A % B is   +3
A rem B is +3
A mod B is +3
A ** B is  +2187
EOF
comp out exp
comp err nul
echo "OK"

# t_arg
title t_arg
echo -e "K\na1\n1\nY\n2\nA\n1\nE" | try t_arg -a1v1 -a2
cat > exp << EOF
>< >t_arg<
 2 arguments.
E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter KEY ? Enter OCCURENCE ? Argument : >v1<
Char ->v<  118
Char ->1<  49
 found at position   1

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter OCCURENCE ? Argument : >a2<
Char ->a<  97
Char ->2<  50
 found at position   2

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter OCCURENCE ? Argument : >-a1v1<
Char ->-<  45
Char ->a<  97
Char ->1<  49
Char ->v<  118
Char ->1<  49
 found at position   1

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : 
EOF
comp out exp
comp err nul
echo "OK"

# t_arg_parser
title t_ada_parser
try t_arg_parser auto
try t_arg_parser -f -m  -m no -o -c -t -c 2
cat > exp << EOF
Parsing OK is TRUE and parsing error string is >OK.<
Number of keys found: 7, Last key at pos: 8, First after at pos: 0 and Nb embedded arguments: 1
Arguments not key are found on 1 occurences.
  Kind: Str  Position:  4  Option >no<
Key f first is found on 1 occurences.
  Kind: Chr  Position:  1  Option ><
Key s second is found on 0 occurences.
Key t third is found on 1 occurences.
  Kind: Chr  Position:  7  Option ><
Key m multi is found on 2 occurences.
  Kind: Chr  Position:  2  Option ><
  Kind: Chr  Position:  3  Option ><
Key o opt is found on 1 occurences.
  Kind: Chr  Position:  5  Option ><
Key c combine is found on 2 occurences.
  Kind: Chr  Position:  6  Option ><
  Kind: Chr  Position:  8  Option >2<
EOF
comp out exp
comp err nul
echo "OK"

# t_asb and t_asu
title t_asb and t_asu
try t_asb
mv out out1
comp err nul
try t_asu
comp err nul
comp out out1
echo "OK"

# t_assert
title t_assert
cat > exp << EOF
This program is normally silent
Set ENV variable ASSERT_ACTION to TRACE to see the 3 traces
 or to RAISE to raise first exception.
EOF
try t_assert
comp out exp
comp err nul
export ASSERT_ACTION=TRACE
try t_assert
comp out exp
comp -n err nul
export ASSERT_ACTION=RAISE
try -n t_assert
comp out exp
comp -n err nul
echo "OK"

# t_async
title t_async
xterm -e "t_async -s 20000 > out 2> err" &
export PID=$!
sleep 0.7
expect \
-c 'spawn telnet localhost 20000; \
  set timeout 1; \
  expect "Nothing"
  send "Toto\n"; \
  sleep 0.3; \
  close' > /dev/null
kill $PID
cat > exp << EOF
Toto
EOF
comp out exp
cat > exp << EOF
connected
disconnected
EOF
comp err exp
echo "OK"

# Skip some tests

# t_autobus
title t_autobus
t_autobus -a > out1 2> err1 &
export PID=$!
sleep 0.7
try t_autobus -a Ah que coucou
kill $PID
cat << EOF > exp
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Spyed >Coucou!<
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Spyed >Coucou!<
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Spyed >Coucou!<
Closing.
Done.
EOF
comp out1 exp
comp err1 nul
comp err nul
echo "OK"

# t_basic
title t_basic
echo -e "toto\ntiti" | t_basic > out 2> err
cat << EOF > exp
toto
titi
EOF
cat << EOF > exp1
End_Error
EOF
comp out exp
comp err exp1
echo "OK"

# t_basic
title t_bloc_io
try t_bloc_io
tail -3 out > tmp
cat << EOF > exp
Dump:  42 
Set index to  5371
Dump:  21 -1 -2  21 
EOF
comp tmp exp
comp err nul
echo "OK"

# t_byte_to_unicode
title t_byte_to_unicode
try t_byte_to_unicode data/ISO-8859-9.xml
grep -E "^222" out > out1
tail -2 out > out2
cat << EOF > exp1
222      16#DE# ->   350     16#15E#
EOF
cat << EOF > exp2
255      16#FF# ->   255      16#FF#

EOF
comp out1 exp1
comp out2 exp2
comp err nul
echo "OK"

# t_c_nbres
title t_c_nbres
try t_c_nbres 1 5 3 -2
cat << EOF > exp
Got:  1.00000000000000E+00 + i * 5.00000000000000E+00
 in polar:  5.09901951359278E+00  1.37340076694502E+00rd  7.86900680000000E+01Â°
Got:  3.00000000000000E+00 - i * 2.00000000000000E+00
 A+B:  4.00000000000000E+00 + i * 3.00000000000000E+00
 A-B: -2.00000000000000E+00 + i * 7.00000000000000E+00
 A*B:  1.30000000000000E+01 + i * 1.30000000000000E+01
 A/B: -5.38461538461538E-01 + i * 1.30769230769231E+00
 A**B.real: -7.40000000000000E+01 - i * 1.10000000000000E+02
EOF
comp out exp
comp err nul
echo "OK"

# t_command
title t_command
try t_command -s /bin/ls t_c*
cat << EOF > exp
Output flow:
>t_channels<
>t_channels.adb<
>t_c_nbres<
>t_c_nbres.adb<
>t_color<
>t_color.adb<
>t_command<
>t_command.adb<
>t_computer<
>t_computer.adb<
>t_con<
>t_con.adb<
>t_cond<
>t_cond.adb<
>t_control_pool<
>t_control_pool.adb<
>t_conv<
>t_conv.adb<
>t_curve<
>t_curve.adb<

Error flow:
><

Exit code:  0
EOF
comp out exp
comp err nul
echo "OK"

# t_computer
title t_computer
try t_computer "V1=5" "V2=2" '3*(${V1}+${V2})'
cat << EOF > exp
Evaluation: 
3*(5+2)
Computation: 
 21
EOF
comp out exp
comp err nul
echo "OK"

# t_cond
title t_cond...
try t_cond
cat << EOF > exp
Main initializing clients
Client  1 initialised
Client  1 getting access
Client  1 trying to wait on condition
Client  2 initialised
Client  2 getting access
Client  2 waiting on condition
Client  3 initialised
Client  3 getting access
Client  3 waiting on condition
Client  4 initialised
Client  4 getting access
Client  4 waiting on condition
Client  1 giving up
Client  1 getting access
Client  1 trying to wait on condition

Main signaling on condition
Client  2 released on condition, releasing access
Client  2 getting access
Client  2 waiting on condition

Main signaling on condition
Client  3 released on condition, releasing access
Client  3 getting access
Client  3 waiting on condition

Main signaling on condition
Client  4 released on condition, releasing access
Client  4 getting access
Client  4 waiting on condition

Main signaling on condition
Client  1 released on condition, releasing access
Client  1 getting access
Client  1 trying to wait on condition

Main signaling on condition
Client  2 released on condition, releasing access
Client  2 getting access
Client  2 waiting on condition

Main signaling on condition
Client  3 released on condition, releasing access
Client  3 getting access
Client  3 waiting on condition

Main broadcasting on condition
Client  4 released on condition, releasing access
Client  4 getting access
Client  1 released on condition, releasing access
Client  1 terminating
Client  2 released on condition, releasing access
Client  2 terminating
Client  3 released on condition, releasing access
Client  3 terminating
Client  4 waiting on condition

Main broadcasting on condition
Client  4 released on condition, releasing access
Client  4 terminating

Main broadcasting on condition

Main signaling on condition

Main terminating

EOF
comp out exp
comp err nul
echo "OK"

fi

# t_conv
title t_conv
try t_conv
cat << EOF > exp
Host:       16#12345678#
to Network: 16#78563412#
to Host:    16#12345678#
EOF
comp out exp
comp err nul
echo "OK"



clean
echo "Done."

