#!/bin/bash

# Automatic tests of tests

# Cleanup
function clean {
  rm -f out out? err err? exp exp? tmp tmp? debug nul pipe Afpx.ref Afpx.res Afpx.tmp
}

trap 'echo ""; clean; exit 1' SIGINT SIGTERM

if [ "$1" = "clean" ]  ; then
  clean
  exit 0
fi
# Finally clean if no error
export final_clean="1"

# Error message
function error {
  echo
  echo $* 2>&1
  final_clean="0"
  exit 1
}

# Function to launch an interactive test
function launch {
  local null=0
  if [ "$1" = "-n" ] ; then
   null=1
   shift
  fi 
  local command=$1
  local help="$2"
  shift
  shift

  echo "Starting $command ($help):"
  if [ $null -eq 1 ] ; then
    $command $* >/dev/null
  else
    $command $* 
  fi
  res=$?
  if [ $res -ne 0 ] ; then
    error "Command $command has failed."
  fi
  echo "$command Done."
}

if [ "$1" = "-clean" ] ; then
  clean
  exit 0
elif [ "$1" = "-ix" ] ; then
  # X11 based => interactive
  launch -n t_x "Click in upper-left corner to stop"
  launch -n t_cards "Click in the \"X\" of the window manager to stop"
  launch -n t_color "Hit Ctrl-C to stop"
  launch -n t_graphic "Hit Ctrl-C to stop"
  launch -n t_key "Hit Ctrl-C to stop"
  launch -n t_con "Enter 'exit' in each window to stop"
  launch -n t_dscr "Hit Return to change Dscr, Esc to stop"
  launch -n t_afpx "Click in 'EXIT' button to stop"
  launch -n t_curve "Hit Esc to stop"
  launch -n t_select_file "Click in 'CANCEL' button to stop"
  launch -n t_timers "Hit Esc to Suspend timers, Ctrl-C to stop"
  clean
  echo "Done."
  exit
elif [ \( "$1" = "-h" \) -o \( "$1" = "--help" \) ] ; then
  echo "Usage: `basename $0` [ -ix | -clean ]" 2>&1
  exit 1
fi

echo -n >nul
# Utilities for automatic tests
# Title
function title {
  echo -n $* ": "
}

# Launch a test 
function try {
  local ok=1
  if [ $1 = "-n" ] ; then
    ok=0
    shift
  fi
  $@ >out 2>err
  res=$?
  if [ $ok -eq 1 ] ; then
    if [ $res -ne 0 ] ; then
      error "Test $1 has failed."
    fi
  else
    if [ $res -eq 0 ] ; then
      error "Test $1 should have failed."
    fi
  fi
}

# Compare 2 files
function comp {
  local ok=1
  if [ $1 = "-n" ] ; then
    ok=0
    shift
  fi
  cmp $1 $2 2>/dev/null
  res=$?
  if [ $ok -eq 1 ] ; then
    if [ $res -ne 0 ] ; then
      error "File $1 differs from expected $2."
      finaL_clean=0
    fi
  else
    if [ $res -eq 0 ] ; then
      error "File $1 should differs from expected $2."
      finaL_clean=0
    fi
  fi
}

# Does $1 match $2 or is $1 "ALL"
function match {
  if [ \( "$1" = "$2" \) -o \( "$1" = "ALL" \) ] ; then
    return 0
  else
    return 1
  fi
}

# Start list of function
arg="$1"
if [ -z "$arg" ] ; then
  arg="ALL"
fi

# t_ada_parser
if `match $arg t_ada_parser` ; then
  title t_ada_parser
  export INPUT=t_ada_parser.adb
  try t_ada_parser $INPUT
  comp out $INPUT
  NB=`wc -l err | awk '{print $1}'`
  export ENB=639
  if [ $NB -ne $ENB ] ; then
    error "File err has incorrect length $NB i.o. $ENB."
  fi
  echo "OK"
fi

# t_afpx_rnb
if `match $arg t_afpx_rnb` ; then
  title t_afpx_rnb...
  t_afpx_rnb >/dev/null 2>&1
  if [ $? -ne 0 ] ; then
    error "t_afpx_rnb has failed".
  fi
  echo "OK"
fi

# t_any
if `match $arg t_any` ; then
  title t_any
  try t_any
  cat >exp << EOF
None_Kind: 
Bool_Kind: True
Trilean_Kind: Other
Integer_Kind: 21
Lint_Kind: 2121
Arbitrary_Kind: 212121
Duration_Kind: 21.210000000
Float_Kind: 2.12100E+01
Real_Kind: 2.12121210000000E+03
Str_Kind: A string
Address_Kind: 16#33C99#
Access_Kind: ->Another string
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_app
if `match $arg t_app` ; then
  title t_app
  t_app
fi

# t_arbitrary
if `match $arg t_arbitrary` ; then
  title t_arbitrary
  try t_arbitrary 21
  cat >exp << EOF
A is        +21
abs A is    +21
-A is       -21
Incr (A) is +22
Decr (A) is +20
A positive  True
Sqrt(A)     +4
Digits: 2 and 1
EOF
  comp err nul
  comp out exp

  try t_arbitrary 3 7
  cat >exp << EOF
A is        +3
abs A is    +3
-A is       -3
Incr (A) is +4
Decr (A) is +2
A positive  True
Sqrt(A)     +1
Digits: 3

B is        +7
abs B is    +7
-B is       -7
Incr (B) is +8
Decr (B) is +6
B positive  True
Sqrt(B)     +2 remaining +3
Prime factors: +7

A =  B is   FALSE
A <  B is   TRUE
A <= B is   TRUE
A >  B is   FALSE
A >= B is   FALSE
A + B is   +10
A - B is   -4
A * B is   +21
A / B is   +0
Roundiv(A, B) is +0
A % B is   +3
A rem B is +3
A mod B is +3
A ** B is  +2187
EOF
  comp err nul
  comp out exp
  try t_arbitrary -a 1000
  comp err nul
  echo "OK"
fi

# t_arbi_list
if `match $arg t_arbi_list` ; then
  title t_arbi_list
  try t_arbi_list --auto
  cat << EOF >exp
Adds 10 elements
Reads 5 elements from the last one: 10 09 08 07 06 
List length: 10 
Deletes the current
Pos from first: 05 List length: 09 
Reads 7 elements from the first one: 01 02 03 04 06 07 08 
Adds the element 50 before current position
Store current access and read: 50 
List length: 10 
Reads 9 elements from the last one: 10 09 50 08 07 06 04 03 02 
Search stored access and read: 50 
Permute 1st and 4th elements, then search 3 from last
Get current pos from first: 03  Get current item: 03 
List (length: 09 ) : 04 02 01 06 07 08 50 09 10 
Seach 50 from first
Seach 50, skipping current
Returns not Found, OK
Pos from first: 07 Pos from last: 03 Can go to next: TRUE Current item, go to next: 50 
Pos from first: 08 Pos from last: 02 Can go to next: TRUE Current item, go to next: 09 
Pos from first: 09 Pos from last: 01 Can go to next: FALSE Current item, go to next: raises Not_In_List, OK
Pos from first: 09 Pos from last: 01 Current item, stay: 10 
Current item, stay: 10 
Iteration
04  is odd
02  is odd
01  is even
06  is odd
07  is even
08  is odd
09  is even
Whole iteration
04  is odd
02  is odd
01  is even
06  is odd
07  is even
08  is odd
50  is odd and stopping iteration
Read raises In_Callback, OK
Delete fully the list
Get current pos from first: raises Empty_List, OK
List length: 00 
Sort the list: 30 50 42 35: 30 35 42 50 
Make the following automatic list: 21 05 30 31 07 21 23 12 
After sorting it: 05 07 12 21 21 23 30 31 
Copied/Inserted in a new list between 21 and 12: 21 05 07 12 21 21 23 30 31 12 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_arg
if `match $arg t_arg` ; then
  title t_arg
  echo -e "K\na1\n1\nY\n2\nA\n1\nE" | try t_arg -a1v1 -a2
  echo >>out
 cat >exp << EOF
>< >t_arg<
 2 arguments.
E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter KEY ? Enter OCCURENCE ? Argument : >v1<
Char ->v<  118
Char ->1<  49
 found at position   1

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter OCCURENCE ? Argument : >a2<
Char ->a<  97
Char ->2<  50
 found at position   2

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : Enter OCCURENCE ? Argument : >-a1v1<
Char ->-<  45
Char ->a<  97
Char ->1<  49
Char ->v<  118
Char ->1<  49
 found at position   1

E : Exit
K : Key
Y : anY_key
N : Not_key
A : Any_arg
Enter the letter of your choice : 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_arg_parser
if `match $arg t_arg_parser` ; then
  title t_arg_parser

  export t_arg_parser_TRACE_Command=Debug
  export t_arg_parser_TRACE_Proc_Family=Debug
  export t_arg_parser_TRACE_Event_Mng=Debug
  export t_arg_parser_TRACEFILE=debug
  try t_arg_parser auto

  try t_arg_parser -f -m  -m no -o opt -c -t -c 2
  cat >exp << EOF
auto for automatic test
-f | --first                 A first single key
-s | --second                A second single key
-t | --third                 A third single key
-m | --multi                 Key that can appear several times
-o <opt> | --opt=<opt>       Key that must have options
-c [<opt>] | --combi[=<opt>] Key that can appear several times and can have options
Parsing OK is TRUE and parsing error string is >OK.<
Number of keys found: 7, Last key at pos: 9, First after at pos: 0 and Nb embedded arguments: 1
Arguments not key are found on 1 occurences.
  Kind: Str  Position:  4  Option >no<
Key f first is found on 1 occurences.
  Kind: Chr  Position:  1  Option ><
Key s second is found on 0 occurences.
Key t third is found on 1 occurences.
  Kind: Chr  Position:  8  Option ><
Key m multi is found on 2 occurences.
  Kind: Chr  Position:  2  Option ><
  Kind: Chr  Position:  3  Option ><
Key o opt is found on 1 occurences.
  Kind: Chr  Position:  5  Option >opt<
Key c combi is found on 2 occurences.
  Kind: Chr  Position:  7  Option ><
  Kind: Chr  Position:  9  Option >2<
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_asb 
if `match $arg t_asb` ; then
  title t_asb
  try t_asb
  comp err nul
  comp out data/t_asbu.ref
  echo "OK"
fi

# t_asu 
if `match $arg t_asu` ; then
  title t_asu
  try t_asu
  comp err nul
  comp out data/t_asbu.ref
  echo "OK"
fi

# t_assert
if `match $arg t_assert` ; then
  title t_assert
  cat >exp << EOF
This program is normally silent
Set ENV variable ASSERT_ACTION to TRACE to see the 3 traces
 or to RAISE to raise first exception.
EOF
  try t_assert
  comp err nul
  comp out exp

  export ASSERT_ACTION=TRACE
  try t_assert
  comp out exp
  comp -n err nul

  export ASSERT_ACTION=RAISE
  try -n t_assert
  comp out exp
  comp -n err nul
  echo "OK"
fi

# t_async
if `match $arg t_async` ; then
title t_async
  t_async -n -s 20000 >out1 2>err1 & 
  export PID=$!
  sleep 0.5
  echo -e "Toto\nTiti\nTata" | try t_async -c localhost:20000
  sleep 0.5
  kill $PID
  cat << EOF >exp
Toto
Titi
Tata
EOF
  cat  << EOF >exp1
connected
disconnected
EOF
  cat  << EOF >exp2
connected
EOF
  comp out1 exp
  comp err1 exp1
  comp err exp2
  echo "OK"
fi

# t_autobus
if `match $arg t_autobus` ; then
  title t_autobus
  export AUTOBUS_CONFIG=data/Autobus.xml
  t_autobus -a >out1 2>err1 &
  export PID=$!
  sleep 0.7
  try t_autobus -a Ah que coucou
  kill $PID
  echo >>out1
  cat << EOF >exp
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Received Ah que coucou -> Replying Coucou!
Spyed >Ah que coucou<
Closing.
Done.
EOF
last=`tail -1 out1`
if [ "$last" = "" ] ; then
  head -8 out1 > out2
else
  cat out1 > out2
fi
  comp err1 nul
  comp err nul
  comp out2 exp
  echo "OK"
fi

# t_basic
if `match $arg t_basic` ; then
  title t_basic
  echo -e "tata\ntete\ntiti\ntoto\ntutu" | t_basic >out 2>err
  cat << EOF >exp
tata
tete
titi
toto
tutu
EOF
  cat << EOF >exp1
End_Error
EOF
  comp out exp
  comp err exp1
  echo "OK"
fi

# t_bencode
if `match $arg t_bencode` ; then
  title t_bencode
  BENCOD='6:Dictiod7:1OneInti1e8:2TwoListli10e6:Eleven5:Empty0:e4:3Tab1:\t9:4Negativei-21ee'
  echo -en "$BENCOD" >exp
  XML=`echo -en $BENCOD | t_bencode -c -b2x 2>err`
  BDECOD=`echo -n $XML | t_bencode -c -x2b 2>>err`
  echo -en "$BDECOD" >out
  comp err nul
  comp out exp

  BENCOD='6:Dictiod7:1OneInti1e8:2TwoListli10e6:Eleven5:Empty0:e4:3Tab1:\t9:3Negativei-21ee'
  echo -en "$BENCOD" >exp
  XML=`echo -en $BENCOD | t_bencode -b2x 2>err`
  BDECOD=`echo -n $XML | t_bencode -x2b 2>>err`
  echo -en "$BDECOD" >out
  comp err nul
  comp out exp
  echo -en $BENCOD | t_bencode -c -b2x >out 2>err
  if [ $? -ne 1 ] ; then
    cat err
    error "t_bencode shall have detected dictio error"
  fi
  comp out nul

  BENCOD='6:Dictiod7:1OneInti1e8:2TwoListli10e6:Eleven5:Empty0:ei21e1:\t9:3Negativei-21ee'
  echo -en "$BENCOD" >exp
  XML=`echo -en $BENCOD | t_bencode -b2x 2>err`
  BDECOD=`echo -n $XML | t_bencode -x2b 2>>err`
  echo -en "$BDECOD" >out
  comp err nul
  comp out exp
  echo -en $BENCOD | t_bencode -c -b2x >out 2>err
  if [ $? -ne 1 ] ; then
    cat err
    error "t_bencode shall have detected dictio error"
  fi
  comp out nul

  EXP='6:Dictiod7:1OneInti1e8:2TwoListli10e6:Eleven5:Empty0:e9:3Negativei-21e4:3Tab1:\te'
  echo -en "$EXP" >exp
  BENCOD='6:Dictiod7:1OneInti1e8:2TwoListli10e6:Eleven5:Empty0:e4:3Tab1:\t9:3Negativei-21ee'
  XML=`echo -en $BENCOD | t_bencode -s -b2x 2>err`
  BDECOD=`echo -n $XML | t_bencode -x2b 2>>err`
  echo -en "$BDECOD" >out
  comp err nul
  comp out exp
  XML=`echo -en $BENCOD | t_bencode -b2x 2>err`
  BDECOD=`echo -n $XML | t_bencode -s -x2b 2>>err`
  echo -en "$BDECOD" >out
  comp err nul
  comp out exp
  echo "OK"
fi

# t_bloc_io
if `match $arg t_bloc_io` ; then
  title t_bloc_io
  try t_bloc_io
  try t_bloc_io
  tail -3 out >tmp
  cat << EOF >exp
Dump:  42 
Set index to  5371
Dump:  21 -1 -2  21 
EOF
  comp err nul
  comp tmp exp
  echo "OK"
fi

# t_byte_to_unicode
if `match $arg t_byte_to_unicode` ; then
  title t_byte_to_unicode
  try t_byte_to_unicode data/ISO-8859-9.xml
  grep -E "^222" out >out1
  tail -2 out >out2
  cat << EOF >exp1
222 16#DE# ->   350 16#15E#
EOF
  cat << EOF >exp2
254 16#FE# ->   351 16#15F#
255 16#FF# ->   255 16#FF#
EOF
  comp err nul
  comp out1 exp1
  comp out2 exp2
  echo "OK"
fi

# t_complexes
if `match $arg t_complexes` ; then
  title t_complexes
  try t_complexes 1 5 3 -2
  cat << EOF >exp
Got:  1.000000000000000E+00 + i * 5.000000000000000E+00
 in polar:  5.09901951359278E+00  1.37340076694502E+00rd  7.86900675259798E+01°
Got:  3.000000000000000E+00 - i * 2.000000000000000E+00
 A+B:  4.000000000000000E+00 + i * 3.000000000000000E+00
 A-B: -2.000000000000000E+00 + i * 7.000000000000000E+00
 A*B:  1.300000000000000E+01 + i * 1.300000000000000E+01
 A/B: -5.384615384615380E-01 + i * 1.307692307692310E+00
 A**B.real: -7.400000000000010E+01 - i * 1.100000000000000E+02
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_command
if `match $arg t_command` ; then
  title t_command
  export t_command_TRACE_Command=Debug
  export t_command_TRACE_Proc_Family=Debug
  export t_command_TRACE_Event_Mng=Debug
  export t_command_TRACEFILE=debug
  try t_command -s /bin/ls t_c*
  cat << EOF >exp
Output flow:
>t_cards<
>t_cards.adb<
>t_channels<
>t_channels.adb<
>t_color<
>t_color.adb<
>t_command<
>t_command.adb<
>t_complexes<
>t_complexes.adb<
>t_computer<
>t_computer.adb<
>t_con<
>t_con.adb<
>t_cond<
>t_cond.adb<
>t_control_pool<
>t_control_pool.adb<
>t_conv<
>t_conv.adb<
>t_curve<
>t_curve.adb<

Error flow:
><

Exit code:  0
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_computer
if `match $arg t_computer` ; then
  title t_computer
  try t_computer "V1=5" "V2=2" '3*(${V1}+${V2})'
  cat << EOF >exp
Evaluation: 
3*(5+2)
Computation: 
+21
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_cond
if `match $arg t_cond` ; then
  title t_cond...
  try t_cond
  comp err nul
  echo "OK"
fi

# t_control_pool
if `match $arg t_control_pool` ; then
  title t_control_pool...
  t_control_pool >out 2>err &
  PID=$!
  sleep 3
  kill $PID
  sleep 5
  comp err nul
  echo "OK"
fi

# t_conv
if `match $arg t_conv` ; then
  title t_conv
  try t_conv
  cat << EOF >exp
Host:       16#12345678#
to Network: 16#78563412#
to Host:    16#12345678#
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_date_text
if `match $arg t_date_text` ; then
  title t_date_text
  t_date_text -s '%b %d %H:%M:%S' '%Y-%m-%dT%H:%M:%S:%s' 'Jul 21 10:45:54' >out 2>err
  cat << EOF >exp
Lengths:
Scan:  15 Strict
Put:   23
Input: Jul 21 10:45:54  Dump: 1901-07-21T10:45:54.000  Put: 1901-07-21T10:45:54:000
EOF
  comp err nul
  comp out exp

  t_date_text  "%Y-%m-%dT%H:%M:%S" "%Y%m%d" "2022-08-17T16:53:19Z" >out 2>err
  cat << EOF >exp
Lengths:
Scan:  19
Put:   8
Input: 2022-08-17T16:53:19Z  Dump: 2022-08-17T16:53:19.000  Put: 20220817
EOF
  comp err nul
  comp out exp

  echo "OK"
fi

# t_day_mng
if `match $arg t_day_mng` ; then
  title t_day_mng
  echo  -e "5\n600\n57000\n" | try t_day_mng 
  echo >>out
  cat << EOF >exp
Enter a duration:  5.000000000
 0 h   0 min   5 sec   0 msec

Enter a duration:  600.000000000
 0 h   10 min   0 sec   0 msec

Enter a duration:  57000.000000000
 15 h   50 min   0 sec   0 msec

Enter a duration: 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_dd
if `match $arg t_dd` ; then
  title t_dd
  try t_dd 10000
  cat << EOF >exp
This test succeeds if no STORAGE_ERROR is raised.
Performinig  10000 iterations, each of them consisting in
 allocating  256 objects of  1024 bytes then freeing them.
Test successful.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_delta_date
if `match $arg t_delta_date` ; then
  title t_delta_date
  try t_delta_date 2012-07-02T15:47:12.514 1963-10-25T21:21:21.210
  cat << EOF >exp
2012/07/02 15:47:12.514 is a MONDAY
1963/10/25 21:21:21.210 is a FRIDAY
 Date1 - Date2: 17782 days 66351.304 sec
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_dirname
if `match $arg t_dirname` ; then
  title t_dirname
  try t_dirname
  cat << EOF >exp
Dirname /tools/toto.ads: /tools/
Dirname toto.ads: 
Dirname /toto.ads: /
Basename /tools/toto.ads: toto.ads
Basename toto.ads: toto.ads
Basename /toto.ads: toto.ads
Basename /tools/toto.ads .ads: toto
Basename /tools/toto.a .ad: toto.a
File_Prefix /tools/toto.ads: toto
File_Suffix /tools/toto.ads: .ads
Normalize /root/dir1/../dirok/./dir3/../toto.ads: /root/dirok/toto.ads
Make_Full "": ${HOME}/ada/usr/tests
Make_Full ".": ${HOME}/ada/usr/tests
Make_Full dir1/../dirok/./dir3/../toto.ads: /home/malaise/ada/usr/tests/dirok/toto.ads
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_door
if `match $arg t_door` ; then
  title t_door...
  try t_door
  comp err nul
  echo "OK"
fi

# t_dur_image
if `match $arg t_dur_image` ; then
  title t_dur_image
  try t_dur_image 1000
  comp err nul
  echo "OK"
fi

# t_dyn_list
if `match $arg t_dyn_list` ; then
  title t_dyn_list
  try t_dyn_list --auto
  cat << EOF >exp
Adds 10 elements
Reads 5 elements from the last one: 10 09 08 07 06 
List length: 10 
Deletes the current
Pos from first: 05 List length: 09 
Reads 7 elements from the first one: 01 02 03 04 06 07 08 
Adds the element 50 before current position
Store current access and read: 50 
List length: 10 
Reads 9 elements from the last one: 10 09 50 08 07 06 04 03 02 
Search stored access and read: 50 
Permute 1st and 4th elements, then search 3 from last
Get current pos from first: 03  Get current item: 03 
List (length: 09 ) : 04 02 01 06 07 08 50 09 10 
Seach 50 from first
Seach 50, skipping current
Returns not Found, OK
Pos from first: 07 Pos from last: 03 Can go to next: TRUE Current item, go to next: 50 
Pos from first: 08 Pos from last: 02 Can go to next: TRUE Current item, go to next: 09 
Pos from first: 09 Pos from last: 01 Can go to next: FALSE Current item, go to next: raises Not_In_List, OK
Pos from first: 09 Pos from last: 01 Current item, stay: 10 
Current item, stay: 10 
Iteration
04  is odd
02  is odd
01  is even
06  is odd
07  is even
08  is odd
09  is even
Whole iteration
04  is odd
02  is odd
01  is even
06  is odd
07  is even
08  is odd
50  is odd and stopping iteration
Read raises In_Callback, OK
Delete fully the list
Get current pos from first: raises Empty_List, OK
List length: 00 
Sort the list: 30 50 42 35: 30 35 42 50 
Make the following automatic list: 21 05 30 31 07 21 23 12 
After sorting it: 05 07 12 21 21 23 30 31 
Copied/Inserted in a new list between 21 and 12: 21 05 07 12 21 21 23 30 31 12 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_evp digest
if `match $arg t_evp_digest` ; then
  title t_evp_digest
  try t_evp_digest sha1 tototititata
  cat << EOF >exp
f56dfd658d9bf8e36df4223218f5e9cec128e287 (20 bytes)
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_exception_messenger
if `match $arg t_exception_messenger` ; then
  title t_exception_messenger
  try t_exception_messenger
  cat << EOF >exp
Checking >The message<
Ok
Checking a long message
Ok
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_fifo
if `match $arg t_fifo` ; then
  title t_fifo
  try t_fifo
  cat << EOF >exp
Fifo size is  5
Push  1
Look  1 -->  1
Look done
Push  2
Look  1 -->  2
Look  2 -->  1
Look done
Push  3
Look  1 -->  3
Look  2 -->  2
Look  3 -->  1
Look done
Push  4
Look  1 -->  4
Look  2 -->  3
Look  3 -->  2
Look  4 -->  1
Look done
Push  5
Look  1 -->  5
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  6
FIFO full. Discard last then push again
Look  1 -->  6
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  7
FIFO full. Discard last then push again
Look  1 -->  7
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  8
FIFO full. Discard last then push again
Look  1 -->  8
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  9
FIFO full. Discard last then push again
Look  1 -->  9
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1
Push  10
FIFO full. Discard last then push again
Look  1 -->  10
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look  5 -->  1

Pop ==>  1
Look  1 -->  10
Look  2 -->  4
Look  3 -->  3
Look  4 -->  2
Look done

Pop ==>  2
Look  1 -->  10
Look  2 -->  4
Look  3 -->  3
Look done

Pop ==>  3
Look  1 -->  10
Look  2 -->  4
Look done

Pop ==>  4
Look  1 -->  10
Look done

Pop ==>  10
FIFO empty
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_file_hash
if `match $arg t_file_hash` ; then
  title t_file_hash
  try t_file_hash t_file_hash.adb begin
  cat << EOF >exp
begin -> 
FOUND at line 10 >begin<
EOF
  comp err nul
  comp out exp

  try t_file_hash t_file_hash.adb procedure
  cat << EOF >exp
procedure -> 
NOT FOUND
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_fork
if `match $arg t_fork` ; then
  title t_fork
  try t_fork /bin/ls
  comp err nul

  try -n t_fork /bin/lsd
  cat << EOF >exp
Child mutation has failed!
EOF
  comp err exp
  echo "OK"
fi

# t_fraction
if `match $arg t_fraction` ; then
  title t_fraction
  try t_fraction 1:3 1:6
  cat << EOF >exp
A is        +1:3
abs A is    +1:3
-A is       -1:3
B is        +1:6
abs B is    +1:6
-B is       -1:6
A =  B is   FALSE
A <  B is   FALSE
A <= B is   FALSE
A >  B is   TRUE
A >= B is   TRUE
A + B is   +1:2
A - B is   +1:6
A * B is   +1:18
A / B is   +2:1
A ** B.Num is +1:3
Set (1,0) raises Constraint_Error, OK.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_getenv
if `match $arg t_getenv` ; then
  title t_getenv
  unset GETENV
  try -n t_getenv
  cat << EOF >exp
GETENV Not set
EOF
  tail -1 out >tmp
  comp err nul
  comp tmp exp

  export GETENV="test is OK."
  try t_getenv
  cat << EOF >exp
GETENV ->test is OK.<
EOF
  tail -1 out >tmp
  comp err nul
  comp tmp exp
  echo "OK"
fi

# t_get_line
if `match $arg t_get_line` ; then
  title t_get_line
  try t_get_line t_get_line.adb
  cat << EOF >exp
003 ->   5:>with<>Argument,<>Get_Line,<>Normal,<>Basic_Proc;<
004 ->   3:>procedure<>T_Get_Line<>is<
006 ->   1:>begin<
008 ->   5:>if<>Argument.Get_Nbre_Arg<>/=<>1<>then<
009 ->   6:>Basic_Proc.Put_Line_Output<>("ERROR.<>Syntax<>:<>t_get_line<><file_name>");<
010 ->   1:>return;<
011 ->   2:>end<>if;<
013 ->   1:>declare<
014 ->   6:>package<>My_Get_Line<>is<>new<>Get_Line<>("--");<
016 ->   1:>begin<
019 ->   1:>begin<
020 ->   2:>My_Get_Line.Open<>(Argument.Get_Parameter);<
021 ->   1:>exception<
022 ->   3:>when<>others<>=><
023 ->   5:>Basic_Proc.Put_Line_Output<>("ERROR<>opening<>file<>"<
024 ->   4:>&<>Argument.Get_Parameter<>&<>".");<
025 ->   1:>raise;<
026 ->   1:>end;<
029 ->   1:>loop<
030 ->   5:>Basic_Proc.Put_Output<>(Normal<>(Integer<>(My_Get_Line.Get_Line_No),<>3,<
031 ->   7:>Gap<>=><>'0')<>&<>"<>-><>");<
032 ->   6:>Basic_Proc.Put_Output<>(Normal<>(My_Get_Line.Get_Word_Number,<>3)<>&<>":");<
033 ->   1:>declare<
034 ->   6:>Line<>:<>constant<>My_Get_Line.Line_Array<>:=<>My_Get_Line.Get_Words;<
035 ->   1:>begin<
036 ->   7:>for<>I<>in<>1<>..<>My_Get_Line.Get_Word_Number<>loop<
037 ->   6:>Basic_Proc.Put_Output<>(">"<>&<>Line(I).Image<>&<>"<");<
038 ->   2:>end<>loop;<
039 ->   1:>end;<
040 ->   1:>Basic_Proc.New_Line_Output;<
041 ->   1:>My_Get_Line.Read_Next_Line;<
042 ->   2:>end<>loop;<
044 ->   1:>exception<
045 ->   3:>when<>My_Get_Line.End_Error<>=><
046 ->   1:>My_Get_Line.Close;<
047 ->   2:>Basic_Proc.Put_Line_Output<>("Done.");<
048 ->   1:>end;<
050 ->   2:>end<>T_Get_Line;<
Done.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_hexa_utils
if `match $arg t_hexa_utils` ; then
  title t_hexa_utils
  try t_hexa_utils -21 32767 6 12 68 -20 -1 0
  cat << EOF >exp
>ffeb<
>7fff<
>6<
>c<
>44<
>ffec<
>ffff<
>0<
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_init_mng
if `match $arg t_init_mng` ; then
  title t_init_mng...
  try t_init_mng
  comp err nul
  echo "OK"
fi

# t_input_buffer
if `match $arg t_input_buffer` ; then
  title t_input_buffer
  try t_input_buffer t_input_buffer.adb
  comp err nul
  comp out t_input_buffer.adb
  echo "OK"
fi

# t_lifo
if `match $arg t_lifo` ; then
  title t_lifo
  try t_lifo
  cat << EOF >exp
Lifo size is  5
Push  1
Look  1 -->  1
Look done
Push  2
Look  1 -->  1
Look  2 -->  2
Look done
Push  3
Look  1 -->  1
Look  2 -->  2
Look  3 -->  3
Look done
Push  4
Look  1 -->  1
Look  2 -->  2
Look  3 -->  3
Look  4 -->  4
Look done
Push  5
Look  1 -->  1
Look  2 -->  2
Look  3 -->  3
Look  4 -->  4
Look  5 -->  5
Push  6
LIFO full. Discard last then push again
Look  1 -->  2
Look  2 -->  3
Look  3 -->  4
Look  4 -->  5
Look  5 -->  6
Push  7
LIFO full. Discard last then push again
Look  1 -->  3
Look  2 -->  4
Look  3 -->  5
Look  4 -->  6
Look  5 -->  7
Push  8
LIFO full. Discard last then push again
Look  1 -->  4
Look  2 -->  5
Look  3 -->  6
Look  4 -->  7
Look  5 -->  8
Push  9
LIFO full. Discard last then push again
Look  1 -->  5
Look  2 -->  6
Look  3 -->  7
Look  4 -->  8
Look  5 -->  9
Push  10
LIFO full. Discard last then push again
Look  1 -->  6
Look  2 -->  7
Look  3 -->  8
Look  4 -->  9
Look  5 -->  10

Pop ==>  10
Look  1 -->  6
Look  2 -->  7
Look  3 -->  8
Look  4 -->  9
Look done

Pop ==>  9
Look  1 -->  6
Look  2 -->  7
Look  3 -->  8
Look done

Pop ==>  8
Look  1 -->  6
Look  2 -->  7
Look done

Pop ==>  7
Look  1 -->  6
Look done

Pop ==>  6
LIFO empty
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_lock
if `match $arg t_lock` ; then
  title t_lock...
  try t_lock
  comp err nul
  echo "OK"
fi

# t_many_strings
if `match $arg t_many_strings` ; then
  title t_many_strings
  try t_many_strings toto titi tata
  cat << EOF >exp
Autotest OK.
Got 3 substrings:
>toto<
>titi<
>tata<
2nd substring >titi<
After split:
>toto<
>titi<
>tata<
This should raise String_Error
String_Error raised.
Arg test OK.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_math
if `match $arg t_math` ; then
  title t_math
  echo -ne "21.0\n6.5\n" | try t_math 
  echo >>out
  cat << EOF >exp
Enter a real R1 : ? int   (R1) 2.10000000000000E+01
frac  (R1) 0.00000000000000E+00
round (R1) 21
trunc (R1) 21
sqrt (R1) 4.58257569495584E+00
exp (R1) 1.31881573448321E+09
ln  (R1) 3.04452243772342E+00
lg  (R1) 1.32221929473392E+00
Angles in radian
sin (R1) 8.36655638536056E-01
cos (R1) -5.47729260224268E-01
tan (R1) -1.52749852763660E+00
arc_sin (R1) Exception
arc_cos (R1) Exception
arc_tan (R1) 1.52321322351791E+00
Enter another real R2 : ?  roundiv (round(R1), round(R2)) 3
 R1 ** R2 3.93029741545242E+08
 R1 div Inte(R2) 3 & 3.00000000000000E+00

Enter a real R1 : ? 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_mut
if `match $arg t_mut` ; then
  title t_mut...
  echo -e "bwiwwwtt" | try t_mut s
  cat << EOF >exp
    Start of critical section for   1
    Mutex not free for   2
    Mutex not free for   2
    Mutex not free for   2
    Mutex not free for   2
    End   of critical section for   1
    Start of critical section for   2
    Termination of   1
    End   of critical section for   2
    Termination of   2

Done.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_network
if `match $arg t_network` ; then
  title t_network
  try t_network
  cat << EOF >exp
Creating Node1 to 3.
Connecting 1-2 1-3 2-3 3-2
Node1 -> Node2  2, Node3  3, 
Node2 -> Node1  1, Node3  3, Node3  3, 
Node3 -> Node1  1, Node2  2, Node2  2, 
Creating temporary Node4 connected with Node2
Deleting first connection of Node1
Node1 -> Node3  3, 
Node2 -> Node3  3, Node3  3, 
Node3 -> Node1  1, Node2  2, Node2  2, 
Deleting all connections between Node2 and Node3
Node1 -> Node3  3, 
Node2 -> 
Node3 -> Node1  1, 
Deleting all connections of Node3
Node1 -> 
Node2 -> 
Node3 -> 
Done.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_normal
if `match $arg t_normal` ; then
  title t_normal
  echo -en "21\n5\ntrue\n*\n" | try t_normal
  echo "" >>out
  cat << EOF >exp
I ? : LEN ? : RIGHT ? : GAP ? : 0         1         2         3         4         5
012345678901234567890123456789012345678901234567890
>***21<

I ? : 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_normalization
if `match $arg t_normalization` ; then
  title t_normalization
  export t_normalization_TRACE_Command=Debug
  export t_normalization_TRACE_Proc_Family=Debug
  export t_normalization_TRACE_Event_Mng=Debug
  export t_normalization_TRACEFILE=debug
  try t_normalization -a
  cat << EOF >exp
 3.14159E+00 10 3 > 3.14E+000< >  3.14159@< >  3.14159@< -> OK
 3.14159E+01 10 3 > 3.14E+001< > 31.415899< > 31.41589@< -> OK
 1.00000E+01 10 3 > 1.00E+001< > 10.0@@@@@< > 10.00000@< -> OK
 1.01000E+01 10 3 > 1.01E+001< > 10.1@@@@@< > 10.10000@< -> OK
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_num_letters
  if `match $arg t_num_letters` ; then
  title t_num_letters
  try t_num_letters 1 2 3 4 5 6 7 8 9 0 21 1000000000000 -s 1000000000
  cat << EOF >exp
one
two
three
four
five
six
seven
eight
nine
zero
twenty one
one billion
one billion
EOF
  comp err nul
  comp out exp
  for i in 1 2 3 4 5 6 7 8 9 10 ; do
    v=`t_rnd -m 2147483647`
    t_num_letters $v >exp
    t_num_letters `cat exp` >out1
    t_num_letters `cat out1` >out
    comp err nul
    comp out exp
  done
  echo "OK"
fi

# t_num_match
if `match $arg t_num_match` ; then
  title t_num_match
  try t_num_match 21 1-5,30-40
  cat << EOF >exp
 21 does not match >1-5,30-40<
1, 2, 3, 4, 5, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
EOF
  comp err nul
  comp out exp
  try t_num_match 21 -5,30-40,20-
  cat << EOF >exp
 21 matches >-5,30-40,20-<
0, 1, 2, 3, 4, 5, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 20, 21
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_output_flows
if `match $arg t_output_flows` ; then
  title t_output_flows
  export t_output_flows_TRACE_Command=Debug
  export t_output_flows_TRACE_Proc_Family=Debug
  export t_output_flows_TRACE_Event_Mng=Debug
  export t_output_flows_TRACEFILE=debug
  try t_output_flows
  cat << EOF >exp
Got stdout
Got async stderr
File OK
Test OK
EOF
  cat << EOF >exp1
Stderr OK
EOF
  comp out exp
  comp err exp1
  echo "OK"
fi

# t_parser
if `match $arg t_parser` ; then
  title t_parser
  try t_parser , toto,titi,ta,ta,,
  cat << EOF >exp
Parsing >toto,titi,ta,ta,,< with separator ',':
>toto< >titi< >ta< >ta< >< 

Getting indexes:
Word is >toto< from 1 to 4 separated by ><
Word is >titi< from 6 to 9 separated by >,<
Word is >ta< from 11 to 12 separated by >,<
Word is >ta< from 14 to 15 separated by >,<
Word is >< from 1 to 0 separated by >,,<

Parsing all in one:
Got >toto< of kind Word
Got >,< of kind Separators
Got >titi< of kind Word
Got >,< of kind Separators
Got >ta< of kind Word
Got >,< of kind Separators
Got >ta< of kind Word
Got >,,< of kind Separators

Done.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_passive_timers
if `match $arg t_passive_timers` ; then
  title t_passive_timers...
  try t_passive_timers
  cat << EOF >exp
Starting T1(10, 10) and T2(2, 2)
 and checking each sec until T1 expiration
T1 has not Expired
T2 has not Expired
T1 has not Expired
T2 has not Expired
T1 has not Expired
T2 has Expired
T1 has not Expired
T2 has not Expired
T1 has not Expired
T2 has Expired
T1 has not Expired
T2 has not Expired
T1 has not Expired
T2 has Expired
T1 has not Expired
T2 has not Expired
T1 has not Expired
T2 has Expired
T1 has not Expired
T2 has not Expired
T1 has Expired
Starting T1(1, 1) and checking 5 times each 0.5s
T1 has not Expired
T1 has not Expired
T1 has Expired
T1 has not Expired
T1 has Expired
Starting T3(0, 1) and checking after 0.5 then 1.0
T3 has not Expired
T3 has Expired
Exception Timer_Expired (OK)
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_pattern
if `match $arg t_pattern` ; then
  title t_pattern...
  echo -e auto | t_pattern >out 2>err
  cat << EOF >exp
Called Cb ( 3, 20, 1, tail: >foo<).
OK
Called Cb ( 3, 10, 2, tail: >foo<).
OK
Called Cb ( 3, 30, 1, tail: >alias<).
OK
Called Cb ( 3, 100, 0, tail: >notif<>alias<).
OK
Called Cb ( 3, 40, 1, tail: ).
OK
Called Cb ( 3, 40, 1, tail: ).
OK
Called Cb ( 3, 10, 1, tail: >foo<).
OK
Called Cb ( 3, 10, 2, tail: >foo<).
OK
Auto test OK.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi


# t_perpet
if `match $arg t_perpet` ; then
  title t_perpet
  echo -en "1963\n10\n25\n21\n3\n210\n" | try t_perpet
  echo "" >>out
  cat << EOF >exp
Base :
Year -> Month -> Day -> 
Delta :
Years -> Months ->  Base + Delta: 1985 1 25
 Base - Delta: 1942 7 25

Delta :
Days ->  Base + Delta: 1964 5 22
 Base - Delta: 1963 3 29


Delta :
Years -> 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_proc_father
if `match $arg t_proc_father` ; then
  title t_proc_father...
  try t_proc_father t_proc_child
  export PID=`tail -1 out | cut -d " " -f 5`
  cat << EOF >exp_head
Father:  3 should be closed in child but not  4.
Father: I am father of  ${PID}
Father: Fds are  6,  7 and  9
Father: Read >Child: Fds are  0,  1 and  2<
Father: Read >Child: Read >F2C<<
EOF
  cat << EOF >exp_tail
Father: Read >Child: Read >F2C<<
Father: Read 0
Father: child pid  ${PID} has exited with code  0
EOF
  # Compare head and tail
  head -5 out >out_head
  tail -3 out >out_tail
  comp err nul
  comp out_head exp_head
  comp out_tail exp_tail
  # Make a pseudo exp and clean heads and tails
  echo "..." >>exp_head
  cat exp_head exp_tail >exp
  rm exp_head exp_tail out_head out_tail
  echo "OK"
fi

# t_read_write
if `match $arg t_read_write` ; then
  title t_read_write...
  try t_read_write
  echo "OK"
fi

# t_recursive_mutex
if `match $arg t_recursive_mutex` ; then
  title t_recursive_mutex
  try t_recursive_mutex
  echo "OK"
fi

# t_regex_filters
if `match $arg t_regex_filters` ; then
  title t_regex_filters
  echo -e "toto\ntiti\nlolo\nlili\n" | try t_regex_filters T t.t. T .i.i F
  cat << EOF >exp
Check toto -> True
Check titi -> False
Check lolo -> False
Check lili -> False
EOF
  comp err nul
  comp out exp
  echo -e "toto\ntiti\nlolo\nlili\n" | try t_regex_filters F t.t. T .i.i F
  cat << EOF >exp
Check toto -> True
Check titi -> True
Check lolo -> True
Check lili -> False
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_regexp
if `match $arg t_regexp` ; then
  title t_regexp
  try t_regexp "t.t." toto
  cat << EOF >exp
String >toto< matches at pos [1-4/4]
EOF
  comp err nul
  comp out exp
  try -n t_regexp "t.t." tolo
  cat << EOF >exp
String >tolo< does not match
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_romanic
if `match $arg t_romanic` ; then
  title t_romanic
  try t_romanic
  try t_romanic 1963
  cat << EOF >exp
1963 -> MCMLXIII
EOF
  comp err nul
  comp out exp
  try t_romanic MMXII
  cat << EOF >exp
MMXII ->  2012
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_round_at
if `match $arg t_round_at` ; then
  title t_round_at
  try t_round_at 215.0 1
  cat << EOF >exp
Digits:  3
Image ->  2.20000000000000E+02
Normalization ->  2.200E+02
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_rnd
if `match $arg t_rnd` ; then
  title t_rnd
  cat << EOF >exp
Total: 1000
EOF
  try t_rnd -g Simple -c
  comp err nul
  tail -1 out > out1
  comp out1 exp

  try t_rnd -g Universal -c
  comp err nul
  tail -1 out > out1
  comp out1 exp

  try t_rnd -g Kiss -c
  comp err nul
  tail -1 out > out1
  comp out1 exp
  echo "OK"
fi


# t_scanner
if `match $arg t_scanner` ; then
  title t_scanner
  t_scanner "%5b %t %d %r %l %i%w %s" "true  maybe 5.2 21.21 21 Try1-Try2 OK" >out 2>err
  cat << EOF >exp
Length: Unknown
Input: true  maybe 5.2 21.21 21 Try1-Try2 OK
 > True
 > Other
 > 5.200000000
 > 2.12100000000000E+01
 > 21
 > Try1
 > -Try2
 > OK
EOF
  comp err nul
  comp out exp

  t_scanner "%4s%s" "toto" >out 2>err
  cat << EOF >exp
Length: Unknown
Input: toto
 > toto
 > 
EOF
  comp err nul
  comp out exp

  echo "OK"
fi

# t_smart_alias
if `match $arg t_smart_alias` ; then
  title t_smart_alias
  try t_smart_alias
  cat << EOF >exp
Test: Begin - Initializing R1 to 21 and R3 to 23
Test: R1 and R3 set - Setting R2 to R1
Test: Dereferencing R3
Test: Dereferenced R3, Got 23 - Dereferencing R2
Test: Dereferenced R2, Got 21 - Dereferencing R1
Test: Dereferenced R1, Got 21 - Releasing R2 and Dereferencing R1
Test: Dereferenced R1. Got 21 - Setting R1 to R3
Finalization of 21
Test: Set R1 to R3. Got R1= 23 and R3= 23 - Releasing R3
Test: R3 released - The end: garbage collecting
Finalization of 23
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_smart_ref
if `match $arg t_smart_ref` ; then
  title t_smart_ref
  try t_smart_ref
  cat << EOF >exp
Test: Begin - Initializing R1 to 21 and R3 to 23
Test: R1 and R3 set - Setting R2 to R1
Test: Dereferencing R3
Test: Dereferenced R3, Got 23 - Dereferencing R2
Test: Dereferenced R2, Got 21 - Dereferencing R1
Test: Dereferenced R1, Got 21 - Releasing R2 and Dereferencing R1
Test: Dereferenced R1. Got 21 - Setting R1 to R3
Finalization of 21
Test: Set R1 to R3. Got R1= 23 and R3= 23 - Releasing R3
Test: R3 released - The end: garbage collecting
Finalization of 23
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_sorts
if `match $arg t_sorts` ; then
  title t_sorts
  try t_sorts 10000
  comp err nul
  echo "OK"
fi

# t_state_machine
if `match $arg t_state_machine` ; then
  title t_state_machine
  echo  -e "Success\nFailure\nSuccess\n" | try t_state_machine data/StateMachine.xml Test
  tail -3 out | head -1 >out1
  cat << EOF >exp
True Default Start Failure Success Attach Detach  ? Transition: Starting -- Success  -> Ok      
EOF
  comp err nul
  comp out1 exp
  echo "OK"
fi

# t_stdin
if `match $arg t_stdin` ; then
  title t_stdin
  mknod pipe p
  cat < pipe >out 2>err &
  echo "Toto" | t_stdin pipe
  sleep 1
  rm pipe
  cat << EOF >exp
Toto
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_str_error
if `match $arg t_str_error` ; then
  title t_str_error
  export t_str_error_TRACE_Command=Debug
  export t_str_error_TRACE_Proc_Family=Debug
  export t_str_error_TRACE_Event_Mng=Debug
  export t_str_error_TRACEFILE=debug
  try t_str_error 21
  cat << EOF >exp
 21 EISDIR          -> Is a directory
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_string 
if `match $arg t_string` ; then
  title t_string
  try t_string -a
  comp err nul
  comp out data/t_asbu.ref
  echo "OK"
fi

# t_strnav
if `match $arg t_strnav` ; then
  title t_strnav
  try t_strnav
  cat << EOF >exp
Init navig to "1234567890", (starting at 8 from init string)
Move by 4 forward (move at 12, containing 5)
Set No_Char to '-'
Lookup -10 -> -
Lookup  -9 -> -
Lookup  -8 -> -
Lookup  -7 -> -
Lookup  -6 -> -
Lookup  -5 -> -
Lookup  -4 -> 1
Lookup  -3 -> 2
Lookup  -2 -> 3
Lookup  -1 -> 4
Lookup   0 -> 5
Lookup   1 -> 6
Lookup   2 -> 7
Lookup   3 -> 8
Lookup   4 -> 9
Lookup   5 -> 0
Lookup   6 -> -
Lookup   7 -> -
Lookup   8 -> -
Lookup   9 -> -
Lookup  10 -> -
Rewind to last
Lookup -10 -> -
Lookup  -9 -> 1
Lookup  -8 -> 2
Lookup  -7 -> 3
Lookup  -6 -> 4
Lookup  -5 -> 5
Lookup  -4 -> 6
Lookup  -3 -> 7
Lookup  -2 -> 8
Lookup  -1 -> 9
Lookup   0 -> 0
Lookup   1 -> -
Lookup   2 -> -
Lookup   3 -> -
Lookup   4 -> -
Lookup   5 -> -
Lookup   6 -> -
Lookup   7 -> -
Lookup   8 -> -
Lookup   9 -> -
Lookup  10 -> -
Move 2 forward
Lookup -10 -> 2
Lookup  -9 -> 3
Lookup  -8 -> 4
Lookup  -7 -> 5
Lookup  -6 -> 6
Lookup  -5 -> 7
Lookup  -4 -> 8
Lookup  -3 -> 9
Lookup  -2 -> 0
Lookup  -1 -> -
Lookup   0 -> -
Lookup   1 -> -
Lookup   2 -> -
Lookup   3 -> -
Lookup   4 -> -
Lookup   5 -> -
Lookup   6 -> -
Lookup   7 -> -
Lookup   8 -> -
Lookup   9 -> -
Lookup  10 -> -
Image:
1234567890
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_syslin
if `match $arg t_syslin` ; then
  title t_syslin
  try t_syslin data/syslin3.dat
  cat << EOF >exp
> 3  2  1   0<
> 2  1 -1   5<
> 1  1  2   8<
Unable to solve: Determinant is nul.
EOF
  comp err nul
  comp out exp
  try t_syslin data/syslin2.dat
  cat << EOF >exp
>2   1      7<
>1   2      8<
X(  1) = 2.00000E+00
X(  2) = 3.00000E+00
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_tcp_util
function test_tcp_util {
  # Start server then client and wait 10s
  t_tcp_util -s -p50000 $1 >outs 2>&1 &
  ser_pid=$!
  sleep 0.3
  t_tcp_util -clocalhost -p50000 $1 $2 >outc 2>&1 &
  cli_pid=$!
  sleep 10
  # Stop client then server
  kill $cli_pid
  sleep 0.1
  kill $ser_pid
  # Check
  sleep 1
  echo "OK" >exp
  tail -n -1 outs >tmps
  tail -n -1 outc >tmpc
  comp tmps exp
  comp tmpc exp
}

if `match $arg t_tcp_util` ; then
  title t_tcp_util inet...
  test_tcp_util "" -l40000
  echo "OK"
  title t_tcp_util afux...
  test_tcp_util -a
  echo "OK"
fi

# t_temp_file
if `match $arg t_temp_file` ; then
  title t_temp_file
  try t_temp_file
  tail -9 out >out1
  cat << EOF >exp
Checking exception on yet another temp file:
Raises No_More_Temp OK

Checking exception on invalid directory:
Raises Invalid_Dir OK

Cleaning temp files.

Done.
EOF
  comp err nul
  comp out1 exp
  echo "OK"
fi

# t_text_char
if `match $arg t_text_char` ; then
  title t_text_char
  try t_text_char t_text_char.adb
  comp err nul
  comp out t_text_char.adb
  echo "OK"
fi

# t_text_line
if `match $arg t_text_line` ; then
  title t_text_line
  cat t_text_line.adb | try t_text_line
  cat t_text_line.adb >exp
  echo >>exp
  comp err nul
  comp out exp
  echo "OK"
fi

# t_timeq
if `match $arg t_timeq` ; then
  title t_timeq...
  echo -e "A\nX\n" | try t_timeq
  echo >>out
  cat << EOF >exp
Insert(Value, Duration) Pop Read(Value) Expire Clear eXit Autotest> 
Ivd | P | Rv | E | C | X | A ? Putting 11 22 44 55 66 and waiting 3 seconds
Popping first without expire
Got 1
Putting 77 then popping all
Got 4
Got 5
Got 6
Got 7
Putting 11 22 44 55 88 and waiting 3 seconds
Reading 1, 2, 4, 5, 8 and 5 again
Not data matches  1
Not data matches  2
Not data matches  3
Read  4
Read  5
Read  5
Putting 11 44 and waiting 3 seconds
Expiring then popping all
Got 8
Got 4
Putting 11 and 66, cleaning then popping all
End of auto test.
Ivd | P | Rv | E | C | X | A ? 
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_trace
if `match $arg t_trace` ; then
  title t_trace
  cat << EOF >out1
Starting
Done
EOF
  export t_trace_TRACE_ALL='0'
  try t_trace
  comp err nul
  comp out out1
  unset t_trace_TRACE_ALL

  function strip_date {
    cat $1 | cut -d ' ' -f 2- >tmp
    mv tmp $1
  }

  export t_trace_TRACE='Info+'
  cat << EOF >err1
t_trace - Error -> Bloga Error
t_trace Blogn Error -> Blogn Error
t_trace - Error -> Loga Error
t_trace Logn Error -> Logn Error
t_trace - Warning -> Bloga Warning
t_trace - Warning -> Loga Warning
t_trace - Info -> Bloga Info
t_trace - Info -> Loga Info
EOF
  try t_trace
  strip_date err
  comp out out1
  comp err err1

  export t_trace_TRACE_Logn='Debug|Info'
  cat << EOF >err1
t_trace - Error -> Bloga Error
t_trace Blogn Error -> Blogn Error
t_trace - Error -> Loga Error
t_trace Logn Error -> Logn Error
t_trace - Warning -> Bloga Warning
t_trace - Warning -> Loga Warning
t_trace - Info -> Bloga Info
t_trace - Info -> Loga Info
t_trace Logn Info -> Logn Info
t_trace Logn Debug -> Logn Debug
EOF
  try t_trace
  strip_date err
  comp out out1
  comp err err1
  echo "OK"
fi

# t_trees
if `match $arg t_trees` ; then
  title t_trees
  try t_trees
  cat << EOF >exp
Inserting 1 as root
Inserting 11 to 15 as root children
 1
    11
    12
    13
    14
    15

Checking that 1 has got 5 children: 1 has got 5 children
Adding 151, 1511 and 15111 as 15 descendents
 1
    11
    12
    13
    14
    15
       151
          1511
             15111

Inserting 0 as root and 2 as elder of 1
 0
    1
       11
       12
       13
       14
       15
          151
             1511
                15111
    2

Replacing 14 by 41 and removing 13
 0
    1
       11
       12
       41
       15
          151
             1511
                15111
    2

Swapping 2 and 15
 0
    1
       11
       12
       41
       2
    15
       151
          1511
             15111

Addind 21 and deleting branch 15
 0
    1
       11
       12
       41
       2
          21

Copying branch 2 below 12
 0
    1
       11
       12
          2
             21
       41
       2
          21

Deleting branch 2
 0
    1
       11
       12
          2
             21
       41

Copying branch 12
T
 0
    1
       11
       12
          2
             21
       41

T'
 12
    2
       21

Swapping 1 and 2 from trees
T
 0
    2
       21

T'
 12
    1
       11
       12
          2
             21
       41

Clearing all
Empty OK.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_ul
if `match $arg t_ul` ; then
  title t_ul
  try t_ul USER 1 ENV=True ENV ENV=False ENV
  cat << EOF >exp
Processing arguments:
Got >USER<->$USER<
Var >1< is not set.
Inserted >ENV=True<
Got >ENV<->True<
Inserted >ENV=False<
Got >ENV<->False<
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_unbounded_arrays
if `match $arg t_unbounded_arrays` ; then
  title t_unbounded_arrays
  try t_unbounded_arrays
  cat << EOF >exp
Empty array:
Length 0
Content 
Image ><
Array of 3:
Image >3<

Array of 1, 3, 5:
Length 3
Content 1, 3, 5
Image >1, 3, 5<
Element 2: 3
Replaced by 21: 21
Image >1, 21, 5<

Append 30, 40, 50, 60, 70
Image >1, 21, 5, 30, 40, 50, 60, 70<
Same with concat
Image >1, 21, 5, 30, 40, 50, 60, 70<
Same with reverse concat
Image >1, 21, 5, 30, 40, 50, 60, 70<
Same with prepend
Image >1, 21, 5, 30, 40, 50, 60, 70<

Slice 4 .. 6
Content 30, 40, 50
Image >30, 40, 50<
Check "=" OK

Replace from 4 to 7 with 41, 51
Image >1, 21, 5, 41, 51, 70<
Delete from 4 to 5, insert 30, 40, 50, 60 before 4
Image >1, 21, 5, 30, 40, 50, 60, 70<
Replace from 4 to 5 with 41, 51, 61
Image >1, 21, 5, 41, 51, 61, 50, 60, 70<
Delete from 4 to 6, insert 30, 40 before 4
Image >1, 21, 5, 30, 40, 50, 60, 70<

Check Finalization
Array of 21, 22
Image >21, 22<
Done.
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_urand
if `match $arg t_urand` ; then
  title t_urand
  try t_urand
  cat << EOF >exp
Expected Results    Actual Results
  6533892.00           6533892.00
 14220222.00          14220222.00
  7275067.00           7275067.00
  6172232.00           6172232.00
  8354498.00           8354498.00
 10633180.00          10633180.00


Random Number Generator Consistent
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_utf
if `match $arg t_utf` ; then
  title t_utf
  try t_utf -unicode E7
  cat << EOF >exp
Unicode : 000000E7
Utf-16  :     00E7
Utf-8   :     C3A7
Utf-8   : ç      
String  : ç
EOF
  comp err nul
  comp out exp
  echo "OK"
fi

# t_utf8
if `match $arg t_utf8` ; then
  title t_utf8
  try t_utf8 10000
  comp err nul
  echo "OK"
fi

# t_utf16
if `match $arg t_utf16` ; then
  title t_utf16
  try t_utf16 1000
  comp err nul
  echo "OK"
fi

# t_virtual
if `match $arg t_virtual` ; then
  title t_virtual...
  try t_virtual
  comp err nul
  echo "OK"
fi

# t_xml_gen
if `match $arg t_xml_gen` ; then
  title t_xml_gen
  try t_xml_gen
  comp out ../misc/variables.xml 
  comp err nul
  echo "OK"
fi

# t_xml_string
if `match $arg t_xml_string` ; then
  title t_xml_string
  # xml_1
  try t_xml_string data/xml_1.xml
  cat << EOF >exp
Parsing file data/dtd_1.dtd
Parsing string of file data/dtd_2.dtd
Parsing file data/dtd_3.dtd
  ---------------------------------------------------------------------------
Parsing prologue of string of file data/xml_1.xml
Got Prologue:
<?xml version="1.1"
      encoding="UTF-8"?>
<?Interface_Name Try_Interface?>
<?Interface_Version 1.0?>

Selected Dtd: 1
Parsing remaining of string
Got Elements:
<try xml:space="preserve">This text is in <bold>bold</bold>.</try>
  ---------------------------------------------------------------------------
EOF
  comp err nul
  comp out exp

  # xml_2
  try t_xml_string data/xml_2.xml
  cat << EOF >exp
Parsing file data/dtd_1.dtd
Parsing string of file data/dtd_2.dtd
Parsing file data/dtd_3.dtd
  ---------------------------------------------------------------------------
Parsing prologue of string of file data/xml_2.xml
Got Prologue:
<?xml version="1.1"
      encoding="UTF-8"?>
<?Interface_Name Try_Interface?>
<?Interface_Version 2.1?>

Selected Dtd: 2
Parsing remaining of string
Got Elements:
<try xml:space="preserve">This text is in <bold>bold</bold>,
 and this one is in <italic>italic</italic>.</try>
  ---------------------------------------------------------------------------
EOF
  comp err nul
  comp out exp

  # xml_3
  try t_xml_string data/xml_3.xml
  cat << EOF >exp
Parsing file data/dtd_1.dtd
Parsing string of file data/dtd_2.dtd
Parsing file data/dtd_3.dtd
  ---------------------------------------------------------------------------
Parsing prologue of string of file data/xml_3.xml
Got Prologue:
<?xml version="1.1"
      encoding="UTF-8"?>
<?Interface_Name Try_Interface?>
<?Interface_Version 3.2?>

Selected Dtd: 3
Parsing remaining of string
Got Elements:
<try xml:space="preserve">This text is in <bold>bold</bold>,
 and this one is in <italic>italic</italic>,
 and this one is in <superscript>superscript</superscript>.</try>
  ---------------------------------------------------------------------------
EOF
  comp err nul
  comp out exp
  try -n t_xml_string data/xml_3_nok.xml
  cat << EOF >exp
Parsing file data/dtd_1.dtd
Parsing string of file data/dtd_2.dtd
Parsing file data/dtd_3.dtd
  ---------------------------------------------------------------------------
Parsing prologue of string of file data/xml_3_nok.xml
Got Prologue:
<?xml version="1.1"
      encoding="UTF-8"?>
<?Interface_Name Try_Interface?>
<?Interface_Version 2.4?>

Selected Dtd: 2
Parsing remaining of string
  ---------------------------------------------------------------------------
EOF
  cat << EOF >exp1
Xml_Parser error at line 7 of xml: Element superscript is not defined in dtd.
EOF
  comp out exp
  comp err exp1

  # Failure of normal parsing of xml_3 (with xml_checker)
  type xml_checker >/dev/null 2>&1
  if [ $? -eq 0 ] ; then
    try -n xml_checker data/xml_3.xml
    grep -q "Element italic is not defined in dtd." err
    res=$?
    if [ $res -ne 0 ] ; then
      error "xml_check on xml_3.xml has produced unexpected result"
    fi
  fi

  echo "OK"
fi

# Clean except if error
if [ "$final_clean" = "1" ] ; then
  clean
fi
echo "Done."

