#!/bin/bash

# Automatic tests of misc

# Cleanup
function clean {
  rm -f cmp res out err expout experr
}

# Error message
function error {
  echo
  echo $* 2>&1
  exit 1
}

# Compare 2 files
function comp {
  local ok=1
  if [ $1 = "-n" ] ; then
    ok=0
    shift
  fi
  cmp $1 $2 2> /dev/null
  res=$?
  if [ $ok -eq 1 ] ; then
    if [ $res -ne 0 ] ; then
      error "File $1 differs from expected $2."
    fi
  else
    if [ $res -eq 0 ] ; then
      error "File $1 should differs from expected $2."
    fi
  fi
}

trap 'echo ""; clean; exit 1' SIGINT SIGTERM

# Read field $3 of line $2 of file $1
function readarg {
res="`awk -vLINE=$2 -vFIELD=$3 '
  BEGIN {
    NL=0
  }
  (NF == 0 || $1 ~ /^#/) {
    # Skip empty lines and comment
    next
  }
  {
    # Count significant lines
    NL=NL+1
    if (NL == LINE) {
      printf "%s",$FIELD
      exit 0
    }
  } 
' $1`"
echo "$res"
}


# One test of compression / uncompression
function cmpr_one {
  export OPT=""
  if [ "$1" = "--lzf" ] ; then
    CMPR="azf -s 900"
    shift
  elif [ "$1" = "--lz4" ] ; then
    CMPR="azf --lz4 -s 900"
    shift
  elif [ "$1" = "--snappy" ] ; then
    CMPR="azf --snappy -s 900"
    shift
  elif [ "$1" = "--lz4l" ] ; then
    CMPR="alz4l -s 3072"
    shift
  fi
  local file=$1

  echo -n $CMPR $file 
  cat $file | $CMPR -c > cmp
  if [ $? -ne 0 ] ; then
    echo
    echo "$CMPR -c $file has failed." 2>&1
    exit 1
  fi
  let ISIZE=0+`ls -l $file | cut -d ' ' -f 5` 
  let CSIZE=0+`ls -l cmp   | cut -d ' ' -f 5` 
  if [ $ISIZE -eq 0 ] ; then
    echo " 0"
  else
    let PER=\($ISIZE-$CSIZE\)*100/$ISIZE
    echo " "$PER"%"
  fi

  cat cmp | $CMPR -d > res
  if [ $? -ne 0 ] ; then
    echo
    echo "$CMPR -d on $file has failed." 2>&1
    exit 1
  fi

  cmp $file res 2>/dev/null
  res=$?
  if [ $res -ne 0 ] ; then
    echo
    echo "File res differs from original $file." 2>&1
    exit 1
  fi
}

# Specific option to do one azf test
if [ "$1"  = "--lzf" ] ; then
  shift
  for file in $* ; do
    cmpr_one --lzf $file
  done
  clean
  exit
elif [ "$1"  = "--lz4" ] ; then
  shift
  for file in $* ; do
    cmpr_one --lz4 $file
  done
  clean
  exit
elif [ "$1"  = "--snappy" ] ; then
  shift
  for file in $* ; do
    cmpr_one --snappy $file
  done
  clean
  exit
elif [ "$1"  = "--lz4l" ] ; then
  shift
  for file in $* ; do
    cmpr_one --lz4l $file
  done
  clean
  exit
fi

# Default
if [ "$1" != "--none" ] ; then
  # Azf on lzf, lz4 and snappy
  for file in `ls *.ads *.adb lib/*` ; do
    cmpr_one --lzf $file
    cmpr_one --lz4 $file
    cmpr_one --snappy $file
    cmpr_one --lz4l $file
  done
  echo ""
fi

# Comp_vars with SET_ME set
echo "comp_vars with SET_ME"
export SET_ME=Momo
comp_vars < variables.xml >out 2>err
cat > expout << EOF
<?xml version="1.1"?>
<Variables>
  <Var Name="V1" Type="Int">5</Var>
  <Var Name="PATH" Type="Str">$PATH:/usr/local/bin</Var>
  <Var Name="V2" Type="Int">125</Var>
  <Var Name="V3" Type="Str">5*125</Var>
  <Var Name="V4" Type="Str"></Var>
  <Var Name="V2" Type="Int">1250</Var>
  <Var Name="Fail" Type="Str">Momo</Var>
</Variables>
EOF
echo -n > experr
comp out expout
comp err experr

# Comp_vars without SET_ME set
echo "comp_vars without SET_ME"
unset SET_ME
comp_vars < variables.xml >out 2>err
cat > experr << EOF 
Error: Environ variable SET_ME not found.
Error processing input flow at line 15 on node Var:
Unknown variable while evaluating variable.
EOF
comp err experr
echo ""

# Intercept
echo -n "" > experr
let L=1
while true ; do
  QFU=`readarg interceptions.txt $L 1`
  if [ "QFU" = "#" ] ; then
    continue;
  fi
  if [ -z "$QFU" ] ; then
    break;
  fi
  HEADING=`readarg interceptions.txt $L 2`
  KIND=`readarg interceptions.txt $L 3`
  case "$KIND" in
    ("You")
      KIND="Final"
      echo  "You are in final heading $QFU." > expout
    ;;
    ("Direct")
      TD1=`readarg interceptions.txt $L  4`
      HD1=`readarg interceptions.txt $L  5`
      TA1=`readarg interceptions.txt $L  6`
      HA1=`readarg interceptions.txt $L  7`
      MA2=`readarg interceptions.txt $L  8`
      TA2=`readarg interceptions.txt $L  9`
      HA2=`readarg interceptions.txt $L 10`
cat > expout << EOF
Direct interception
At DME 30 turn $TD1 heading $HD1 to intercept final heading $QFU.
Alternate indirect interception
At DME 30 turn $TA1 heading $HA1,
at DME 22 QDM $MA2 turn $TA2 heading $HA2 to intercept final heading $QFU.
EOF
    ;;  
    ("Indirect")
      TI1=`readarg interceptions.txt $L  4`
      HI1=`readarg interceptions.txt $L  5`
      MI2=`readarg interceptions.txt $L  6`
      TI2=`readarg interceptions.txt $L  7`
      HI2=`readarg interceptions.txt $L  8`
      TA1=`readarg interceptions.txt $L  9`
      HA1=`readarg interceptions.txt $L 10`
      MA2=`readarg interceptions.txt $L 11`
      TA2=`readarg interceptions.txt $L 12`
      HA2=`readarg interceptions.txt $L 13`
      cat > expout << EOF
Indirect interception
At DME 30 turn $TI1 heading $HI1,
at DME 22 QDM $MI2 turn $TI2 heading $HI2 to intercept final heading $QFU.
Alternate indirect interception
At DME 30 turn $TA1 heading $HA1,
at DME 22 QDM $MA2 turn $TA2 heading $HA2 to intercept final heading $QFU.
EOF
    ;;
    (*)
      echo "Invalid kind $LIND" 1>&2
      exit 1
    ;;
  esac
  echo "intercept $QFU $HEADING $KIND"
  intercept $QFU $HEADING >out 2>err
  comp out expout
  comp err experr
  let L=$L+1
done


# Done
echo "OK"
clean

