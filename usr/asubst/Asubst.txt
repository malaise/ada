1. General syntax
Usage: asubst [ { <option> } ] <find_pattern> <replace_pattern> [ { <file> } ]
Substitutes strings in files.
If no file name is specified, substitutes from stdin to stdout.

2. Find pattern
<find_pattern> ::= { [ <regex> ] \n } [ <regex> ]
If there is no \n, then the regex can be any regular expression.
If there are \n, they delimit several regex that will apply to several lines.
In this case, '^' and '$' are forbidden around a '\n' (they will 
automatically be added). Examples:
r        ->    r
^r$      ->    ^r$
r1\nr2\n -> r1$ and ^r2$
r1\nr2   -> r1$ and ^r2
r1\nr2$  -> r1$ and ^r2$
r1$\n     is forbdiden
The difference between r1\n and r1$ is that r1\n is two regex. With r1\n,
the string matching r1 AND the following New_Line will be substituted. With
r1$, only the string matching r1 will be subtituted.

3. Replace string
Only the following sequences are supported:
- \n will be replaced by a newline,
- \t will be replaced by a (horiz) tab
- \xIJ where IJ is and hexadecimal number (00 to FF or ff) will be replaced
  by a byte with the corresponding value
- \IJ where IJ is and hexadecimal number will be replaced by the string
  matching the corresponding regex number (00 for the complete string).
Examples:
echo "toto" | asubst "t" "\x40"                     ->  "@"
echo "toti" | asubst "t." ">\00<"                   ->  ">to<>ti<"
echo -e "toto\ntiti\ntata\n" | asubst ".*\n" "\01"  ->  tototititata
echo -e "\ntoto\ntiti\ntata" | asubst "\n.*" "\02"  ->  tototititata

