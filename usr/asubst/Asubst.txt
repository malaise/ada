                                 Asubst
                                  V4.5


1. General syntax
Usage: asubst [ { <option> } ] <find_pattern> <replace_string> [ { <file> } ]
or   : asubst -h | --help | -V | --version
Substitutes strings in files.
If no file name is specified, substitutes from stdin to stdout.
See "man 7 regex" for basic and extended regex and for ignorecase pattern
matching.


2. Options
-a or --ascii : consider that input flow or file is pure ASCII.
-b or --basic : use 'basic' regex instead of the default 'extended' regex.
-d or --display : display arguments <find_pattern> and <replace_string>.
-e <pattern> or --exclude=<pattern> for skip text matching <pattern>,
-f or --file : indicate that <file> will contain names of files to process.
-g or --grep : print matching text as grep would do (no substitution).
-i or --ignorecase : do case insensitive match checking of <find_pattern>.
-l or --line for display line number in grep mode.
-m <max> or --max=<max> : stop processing each file after <max> substitutions,
    (0 for infinite).
-n or --number : print number of substitutions per file.
-q or --quiet : for no printout.
-s or --save : make a copy (<file>.asu) of original file(s).
-t or --test for test, substitutions not performed,
-u or --utf8 : process utf-8 sequences.
-v or --verbose : print each substitution and its line number.
-x or --noregex : <find_pattern> is only the string to find, without "\n",
     not a regex. This allows \x00. There is no multiple regex nor substring.
-- : to stop the list of options. If <find_pattern> is "-pat", then use
     asubst [ { <option> } ] -- "-pat" <replace_pattern>  [ { <file> } ].

Grep mode imposes quiet, test and no-backup.
Line_Nb mode is allowed in Grep mode only.

3. Environment
If the LANG environment variable is set to something containing "UTF-8", then asubst
considers that input flow or file is coded in Utf-8. This setting can be
altered in a way or the other by setting ASUBST_UTF8 environment variable
to Y, yes, N or no (with whatever casing). Finally, this setting can be
altered in a way or the other by the options -a (--ascii), or -u (--utf8).

If ASUBST_DEBUG environment variable is set to Y or yes (with whatever casing)
then asubst puts on stderr some debugging information.


4. Find pattern
<find_pattern>   ::= <regex> | <multiple_regex>
<multiple_regex> ::= { [ <regex> ] \n } [ <regex> ]
If there is no "\n", then the regex can be any regular expression. If it
does not start with '^' nor ends with '$', then it is applied several times
to each input line (each time to the text following previous substitution).
Significant '^' and '$' (not backslashed nor in brakets) are then only allowed
respectively at the beginning and at the end of the regex.
Examples:
echo "toto" | asubst "t" "x"                       ->  "xoxo"
echo "toto" | asubst "t" "ti"                      ->  "tiotio"
echo "tito" | asubst "t." "tu"                     ->  "tutu"

If there are "\n", they delimit several regex that will apply to several lines.
Search pattern is split into several regex and \n patterns, each line of input is
split in two input items: text then newline, pattern 1 will be compared to item
1, if they match, pattern 2 will be compared to item 2....
In this case, significant '^' and '$' are only allowed respectively at
the beginning and at the end of the pattern.

Examples:
r        -> r
^r$      -> ^r$
r1\nr2\n -> r1$ \n and ^r2$
r1\nr2   -> r1$ \n and ^r2
r1\nr2$  -> r1$ \n and ^r2$
r1$\n     is forbdidden.
The difference between "r1\n" and "r1$" is that "r1\n" is two regex. With "r1\n",
the string matching "r1" AND the following New_Line will be substituted. With
"r1$", only the string matching "r1" will be subtituted. In short, "r1\n" means
"r1 then a newline" while "r1$" means "r1, followed by a newline".
The following specific '\' sequences are also handled:
- "\s, replaced by a space,
- "\t, replaced by a (horiz) tab,
- "\xIJ" where IJ is an hexadecimal number (00 to FF or ff) for a byte code.
  "\x00" is forbidden in find pattern except in mode "noregex".
  Beware also that \xIJ is replaced before compiling the regex, so it cannot be
  used to avoid a given character. "[a\x2Dx]" is exactly the same as
  "[a-x]", and "\x0A" is exactly the same as "\n" (it will be used as regex
  delimiter).
- The following shortcuts for character classes, to be used in regex within
  brackets:
     "\M" [:alnum:], "\A" [:alpha:], "\B" [:blank:], "\C" [:cntrl:],
     "\D" [:digit:], "\G" [:graph:], "\L" [:lower:], "\P" [:print:],
     "\T" [:punct:], "\S" [:space:], "\U" [:upper:], "\X" [:xdigit:].
  Note that asubst does NOT check if such shortcut is within a bracket
  expression or not. For example, "\M" is always replaced by "[:alnum:]" and,
  out of a bracket expression, this becomes a bracket expression, meaning:
  ':' or 'a' or 'l' or 'n' or 'u' or 'm'.

Note that only "\s", "\t", "\n" and "\xIJ" are interpreted in "noregex" mode.
Finally, beware that some regex expressions are supposed to match a "new line"
(example [:blank:] within a bracket expression) but will not match in asubst,
because the input flow/file is decomposed into lines and then each line is
compared to a regex expression. 


5. Exclusion pattern
If set, the <exclude_regex> must have the same number of regex as the
<find_pattern>. This option means that text matching the <find_pattern> but
also the <exclude_regex> will not be replaced. Beware that it applies to the
text matching <find_pattern> only.
For example echo "toto" | asubst --exclude=toto to ti will replace toto by titi
because each matching "to" does not match the exclusion "toto".
On the other hand, echo "toto" | asubst --exclude=to to ti and
echo "toto" | asubst --exclude=toto toto titi will not substitute.


6. Replace string
The following '\' sequences are supported:
- \n will be replaced by a newline.
- \t will be replaced by a (horiz) tab.
- \xIJ where IJ is an hexadecimal number (00 to FF or ff) will be replaced
  by a byte with the corresponding value.
- \RIJ where IJ is an hexadecimal number will be replaced by the string
  matching the regex number IJ, (0 < IJ <= NbOfRegex).
- \rIJ where IJ is an hexadecimal number will be replaced by the string
  matching the substring J of the regex number I (0 < I), J=0 for the
  complete string, (so \R0x = \rx0).
- \u, \l, \m for starting an UPPER, lower or Mixed case conversion. A
  conversion ends when a new starts, at end of line or on \c.
- \c for stopping a case conversion.
Case conversion applies after (sub)string replacement.

Examples:
echo -en "toto" | asubst "t" "\x40"                     ->  "@"
echo -en "toto\ntiti\ntata\n" | asubst ".*\n" "\R01"    ->  "tototititata"
echo -en "\ntoto\ntiti\ntata" | asubst "\n.*" "\R02"    ->  "tototititata"
echo -en "tito" | asubst "(.i)(.o)"  "\r12<->\r11"      ->  "to<->ti"
echo -en "tito" | asubst ".*" "\m\R01"                  ->  "Tito"
echo -en "toto" | asubst "(.)(.)(..)" "\u\r12\c\r11"    ->  "Otto"


7. Differences between regex and noregex modes
In both modes "\x0A" is the same as "\n", and "\s" and "\t" are interpreted.
"\n" is allowed in find patern in regex mode and used to separate sub patterns,
each applying to a line. It is forbidden in noregex mode where the find
pattern string is always applied several times to each input line.
"\x00" is forbidden in find patern in regex mode (because it is the C string
terminator and is used as such by regex library). It is allowed in noregex mode.
"\A" to "\X" are not interpreted in find patern noregex mode.
In noregex mode, "\rIJ" s forbidden. 


8. Exit code
asubst exits with 0 if some matching was found, with 1 if no matching
was found and with 2 otherwise (e.g. in case of error).

