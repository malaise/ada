                                 Asubst
                                  V2_9


1. General syntax
Usage: asubst [ { <option> } ] <find_pattern> <replace_pattern> [ { <file> } ]
or   : asubst -h | --help | -v | --version
Substitutes strings in files.
If no file name is specified, substitutes from stdin to stdout.
See "man 7 regex" for basic and extended regex and for ignorecase pattern
matching.


2. Options
-b or --basic : use 'basic' regex instead of the default 'extended' regex.
-i or --ignorecase : do case insensitive match checking of <find_pattern>.
-s or --save : make a copy (<file>.asu) of original file(s).
-q or --quiet : for no printout.
-n or --number : print number of substitutions per file.
-v or --verbose : print each substitution and its line number.
-f or --file : indicate that <file> will contain names of files to process.
-m <max> or --max=<max> : stop processing each file after <max> substitutions,
    (0 for infinite).
-- : to stop the list of options. If <find_pattern> is "-b", then use
     asubst [ { <option> } ] -- "-b" <replace_pattern>  [ { <file> } ].


3. Find pattern
<find_pattern> ::= { [ <regex> ] \n } [ <regex> ]
If there is no "\n", then the regex can be any regular expression. If it
does not start with '^' nor ends with '$', then it is applied several times
to each input line (each time to the text following previous substitution).
Examples:
echo "toto" | asubst "t" "x"                       ->  "xoxo"
echo "toto" | asubst "t" "ti"                      ->  "tiotio"
echo "tito" | asubst "t." "tu"                     ->  "tutu"

If there are "\n", they delimit several regex that will apply to several lines.
In this case, '^' and '$' are forbidden around a "\n" (they will automatically be
added).
Search pattern is split into several regex and \n patterns, each line of input is
split in two input items: text then newline, pattern 1 is compared to item 1, if
they match, pattern 2 is compared to item 2.

Examples:
r        -> r
^r$      -> ^r$
r1\nr2\n -> r1$ \n and ^r2$
r1\nr2   -> r1$ \n and ^r2
r1\nr2$  -> r1$ \n and ^r2$
r1$\n     is forbdiden.
The difference between "r1\n" and "r1$" is that "r1\n" is two regex. With "r1\n",
the string matching "r1" AND the following New_Line will be substituted. With
"r1$", only the string matching "r1" will be subtituted.
The following specific '\' sequences are also handled:
- "\t, replaced by a (horiz) tab,
- "\xIJ" where IJ is an hexadecimal number (00 to FF or ff) for a byte code.
Beware that \xIJ is replaced before compilind the regex, so it cannot be
used to avoid a given character. "[a\x2Dx]" is exactly the same as
"[a-x]", and "\x0A" is exactly the same as "\n" (it will be used as regex
delimiter).


4. Replace string
The following '\' sequences are supported:
- \n will be replaced by a newline.
- \t will be replaced by a (horiz) tab.
- \xIJ where IJ is an hexadecimal number (00 to FF or ff) will be replaced
  by a byte with the corresponding value.
- \RIJ where IJ is an hexadecimal number will be replaced by the string
  matching the regex number IJ, 00 for the complete string,
  (in case of a single regex (no "\n") \R00 is equivalent to \R01).
- \rIJ where IJ is an hexadecimal number will be replaced by the string
  matching the substring J of the regex number I, J=0 for the complete string,
  (so \R0x = \rx0).
- \u, \l, \m for starting an UPPER, lower or Mixed case conversion. A
  conversion ends when a new starts, at end of line or on \c.
- \c for stopping a case conversion.
Case conversion applies after (sub)string replacement.

Examples:
echo -en "toto" | asubst "t" "\x40"                     ->  "@"
echo -en "tito" | asubst "t." ">\R00<"                  ->  ">ti<>to<"
echo -en "toto\ntiti\ntata\n" | asubst ".*\n" "\R01"    ->  "tototititata"
echo -en "\ntoto\ntiti\ntata" | asubst "\n.*" "\R02"    ->  "tototititata"
echo -en "tito" | asubst "(.i)(.o)"  "\r12<->\r11"      ->  "to<->ti"
echo -en "tito" | asubst ".*" "\m\R01"                  ->  "Tito"
echo -en "toto" | asubst "(.)(.)(..)" "\u\r12\c\r11"    ->  "Otto"

