<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Asubst</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.2  (Linux)">
	<META NAME="AUTHOR" CONTENT="MALAISE Pascal">
	<META NAME="CREATED" CONTENT="20060414;18573000">
	<META NAME="CHANGEDBY" CONTENT="MALAISE">
	<META NAME="CHANGED" CONTENT="20070727;7355800">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<P LANG="en-GB" ALIGN=CENTER><FONT FACE="monospace"><FONT SIZE=7><B>Asubst</B><BR><FONT SIZE=6><B>V3_8</B></FONT></FONT></FONT></P>
<H1 LANG="en-GB"><FONT FACE="monospace">1. General syntax</FONT></H1>
<P LANG="en-GB"><FONT FACE="monospace">Usage: asubst [ { &lt;option&gt;
} ] &lt;find_pattern&gt; &lt;replace_string&gt; [ { &lt;file&gt; }
]</FONT><BR><FONT FACE="monospace">or&nbsp;&nbsp;&nbsp;: asubst -h |
--help | -V | --version</FONT><BR><FONT FACE="monospace">Substitutes
strings in files.</FONT><BR><FONT FACE="monospace">If no file name is
specified, substitutes from stdin to stdout.</FONT><BR><FONT FACE="monospace">See
&quot;man 7 regex&quot; for basic and extended regex and for
ignorecase pattern matching.</FONT></P>
<H1 LANG="en-GB"><FONT FACE="monospace">2. Options</FONT></H1>
<P LANG="en-GB"><FONT FACE="monospace">-a or --ascii : consider that
input flow or file is pure ASCII.<BR>-b or --basic : use 'basic'
regex instead of the default 'extended' regex for &lt;find_pattern&gt;.<BR>-f
or --file : indicate that &lt;file&gt; contains the names of files to
process.<BR>-g or --grep : print matching text as grep would do (no
substitution).</FONT><BR><FONT FACE="monospace">-i or --ignorecase :
do case insensitive match checking of &lt;find_pattern&gt;.<BR>-m
&lt;max&gt; or --max=&lt;max&gt; : stop processing each file after
&lt;max&gt; substitutions, (0 for infinite).<BR>-n or --number :
print number of substitutions per file.<BR>-q or --quiet : for no
printout.</FONT><BR><FONT FACE="monospace">-s or --save : make a copy
(&lt;file&gt;.asu) of original file(s),<BR></FONT><FONT FACE="monospace"><SPAN LANG="en-GB">-t
or --test for test, substitutions not performed,<BR>-u or --utf8 :
process utf-8 sequences.<BR>-v or --verbose : print each substitution
and its line number</SPAN></FONT><FONT FACE="monospace">.<BR>-x or
--noregex : &lt;find_pattern&gt; is only the string to find, not a
regex. This allows \x00. There is no multiple regex nor substring.</FONT><BR><FONT FACE="monospace">--
: to end the list of options. If &lt;find_pattern&gt; is &quot;-pat&quot;,
then use<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asubst [ { &lt;option&gt; }
] -- &quot;-pat&quot; &lt;replace_pattern&gt; [ { &lt;file&gt; } ].</FONT></P>
<H1 LANG="en-GB"><FONT FACE="monospace">3. Environment</FONT></H1>
<P LANG="en-GB"><FONT FACE="monospace">If the LANG environment
variable is set to something containing “UTF-8&quot;, then asubst
considers that input flow or file is coded in Utf-8. This setting can
be altered in a way or the other by setting ASUBST_UTF8 environment
variable to Y, yes, N or no (with whatever casing). Finally, this
setting can be altered in a way or the other by the options -a
(--ascii), or -u (--utf8).</FONT></P>
<P LANG="en-GB"><FONT FACE="monospace">If ASUBST_DEBUG environment
variable is set to Y or yes (with whatever casing) then asubst puts
on stderr some debugging information.</FONT></P>
<H1 LANG="en-GB"><FONT FACE="monospace">4. Find pattern</FONT></H1>
<P LANG="en-GB"><FONT FACE="monospace">&lt;find_pattern&gt; ::=
&lt;regex&gt; | &lt;multiple_regex&gt;<BR>&lt;multiple_regex&gt; ::=
{ [ &lt;regex&gt; ] \n } [ &lt;regex&gt; ]<BR>If there is no &quot;\n&quot;,
then the regex can be any regular expression. If it does not start
with '^' nor ends with '$', then it is applied several times to each
input line (each time to the text following previous
substitution).</FONT><BR><FONT FACE="monospace">Examples:</FONT><BR><FONT FACE="monospace">echo
&quot;toto&quot; | asubst &quot;t&quot; &quot;x&quot;&nbsp;&nbsp;&nbsp;-&gt;
&quot;xoxo&quot;</FONT><BR><FONT FACE="monospace">echo &quot;toto&quot;
| asubst &quot;t&quot; &quot;ti&quot;&nbsp;&nbsp;-&gt; &quot;tiotio&quot;</FONT><BR><FONT FACE="monospace">echo
&quot;tito&quot; | asubst &quot;t.&quot; &quot;tu&quot;&nbsp;-&gt;
&quot;tutu&quot;</FONT><BR><BR><FONT FACE="monospace">If there are
&quot;\n&quot;, they delimit several regex that will apply to several
successive lines.</FONT><BR><FONT FACE="monospace">In this case, '^'
and '$' are forbidden around a &quot;\n&quot; (they will
automatically be added).</FONT><BR><FONT FACE="monospace">Search
pattern is split into several regex and &quot;\n&quot; patterns, each
line of input is split in two input items: text then newline, pattern
1 is compared to item 1, if they match, pattern 2 is compared to item
2...</FONT><BR><FONT FACE="monospace">Examples:</FONT><BR><FONT FACE="monospace">r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
r</FONT><BR><FONT FACE="monospace">^r$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
^r$</FONT><BR><FONT FACE="monospace">r1\nr2\n&nbsp;-&gt; r1$ \n and
^r2$</FONT><BR><FONT FACE="monospace">r1\nr2&nbsp;&nbsp;&nbsp;-&gt;
r1$ \n and ^r2</FONT><BR><FONT FACE="monospace">r1\nr2$&nbsp;&nbsp;-&gt;
r1$ \n and ^r2$</FONT><BR><FONT FACE="monospace">r1$\n is
forbidden.</FONT><BR><FONT FACE="monospace">The difference between
&quot;r1\n&quot; and &quot;r1$&quot; is that &quot;r1\n&quot; is two
regex. With &quot;r1\n&quot;, the string matching &quot;r1&quot; AND
the following newline will be substituted. With &quot;r1$&quot;, only
the string matching &quot;r1&quot; will be substituted. In short,
&quot;r1\n&quot; means &quot;r1 then a newline&quot; while &quot;r1$&quot;
means &quot;r1, followed by a newline&quot;.<BR><BR>The following
specific '\' sequences are also handled:<BR>- &quot;\s, replaced by a
space,</FONT><BR><FONT FACE="monospace">- &quot;\t, replaced by a
(horiz) tab,</FONT><BR><FONT FACE="monospace">- &quot;\xIJ&quot;
where IJ is an hexadecimal number (00 to FF or ff) for a byte code.
&quot;\x00&quot; is forbidden in find pattern except in mode
&quot;noregex&quot;. Beware also that these sequences are replaced
before compiling the regex, so they cannot be used to avoid a given
character. For example, &quot;[a\x2Dx]&quot; is exactly the same as
&quot;[a-x]&quot;, and &quot;\x0A&quot; is exactly the same as &quot;\n&quot;
(it will be used as regex delimiter).<BR>- The following shortcuts
for character classes, to be used in regex within brackets:<BR>&quot;\M&quot;
[:alnum:], &quot;\A&quot; [:alpha:], &quot;\B&quot; [:blank:], &quot;\C&quot;
[:cntrl:],<BR>&quot;\D&quot; [:digit:], &quot;\G&quot; [:graph:],
&quot;\L&quot; [:lower:], &quot;\P&quot; [:print:],<BR>&quot;\T&quot;
[:punct:], &quot;\S&quot; [:space:], &quot;\U&quot; [:upper:], &quot;\X&quot;
[:xdigit:].<BR>Note that asubst does NOT check if such shortcut is
withing a bracket expression or not. For example, &quot;\M&quot; is
always replaced by &quot;[:alnum:]&quot; and, out of a bracket
expression, this becomes a bracket expression, meaning: ':' or 'a' or
'l' or 'n' or 'u' or 'm'.</FONT></P>
<P LANG="en-GB"><FONT FACE="monospace">Note that only “\s”, “\t”,
“\n” and “\xIJ” are interpreted in “noregex”
mode.<BR>Finally, beware that some regex expressions are supposed to
match a &quot;new line&quot; (example [:blank:] within a bracket
expression) but will not match in asubst, because the input flow/file
is decomposed into lines and then each line is compared to a regex
expression.</FONT> 
</P>
<H1 LANG="en-GB"><FONT FACE="monospace">5. Replace string</FONT></H1>
<P LANG="en-GB"><FONT FACE="monospace">The following '\' sequences
are supported:</FONT><BR><FONT FACE="monospace">- \n will be replaced
by a newline.</FONT><BR><FONT FACE="monospace">- \t will be replaced
by a (horiz) tab.</FONT><BR><FONT FACE="monospace">- \xIJ where IJ is
an hexadecimal number (00 to FF or ff) will be replaced</FONT> <FONT FACE="monospace">by
a byte with the corresponding value.</FONT><BR><FONT FACE="monospace">-
\RIJ where IJ is an hexadecimal number will be replaced by the string
matching the regex number IJ, (0 &lt; IJ &lt;= NbOfRegexps).</FONT><BR><FONT FACE="monospace">-
\rIJ where IJ is an hexadecimal number will be replaced by the string</FONT>
<FONT FACE="monospace">matching the substring J of the regex number
I, J=0 for the complete string,</FONT> <FONT FACE="monospace">(so
\R0x = \rx0).</FONT><BR><FONT FACE="monospace">- \u, \l, \m for
starting an UPPER, lower or Mixed case conversion. A</FONT>
<FONT FACE="monospace">conversion ends when a new starts, at end of
line or on \c.</FONT><BR><FONT FACE="monospace">- \c for stopping a
case conversion.<BR>Case conversion applies after (sub)string
replacement.<BR></FONT><BR><FONT FACE="monospace">Examples:</FONT><BR><FONT FACE="monospace">echo
-en &quot;toto&quot; | asubst &quot;t&quot;
&quot;\x40&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
&quot;@&quot;</FONT><BR><FONT FACE="monospace">echo -en &quot;tito&quot;
| asubst &quot;t.&quot; &quot;&gt;\R00&lt;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
&quot;&gt;ti&lt;&gt;to&lt;&quot;</FONT><BR><FONT FACE="monospace">echo
-en &quot;toto\ntiti\ntata\n&quot; | asubst &quot;.*\n&quot;
&quot;\R01&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
&quot;tototititata&quot;</FONT><BR><FONT FACE="monospace">echo -en
&quot;\ntoto\ntiti\ntata&quot; | asubst &quot;\n.*&quot;
&quot;\R02&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
&quot;tototititata&quot;</FONT><BR><FONT FACE="monospace">echo -en
&quot;tito&quot; | asubst &quot;(.i)(.o)&quot;
&quot;\r12&lt;-&gt;\r11&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
&quot;to&lt;-&gt;ti&quot;</FONT><BR><FONT FACE="monospace">echo -en
&quot;tito&quot; | asubst &quot;.*&quot;
&quot;\m\R01&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;
&quot;Tito&quot;</FONT><BR><FONT FACE="monospace">echo -en &quot;toto&quot;
| asubst &quot;(.)(.)(..)&quot; &quot;\u\r12\c\r11\r13&quot;&nbsp;-&gt;
&quot;Otto&quot;</FONT></P>
<H1 LANG="en-GB">6<FONT FACE="Monospace">.Differences between regex
and noregex modes</FONT></H1>
<P LANG="en-GB"><FONT FACE="Monospace">In both modes &quot;\x0A&quot;
is the same as &quot;\n&quot; and &quot;\s&quot;, &quot;\t&quot; and
&quot;\n&quot; are interpreted.</FONT></P>
<P LANG="en-GB"><FONT FACE="Monospace">&quot;\n&quot; is allowed in
find patern in regex mode and used to separate sub patterns, each
applying to a line. It is forbidden in noregex mode where the find
pattern string is always applied several times to each input line.</FONT></P>
<P LANG="en-GB"><FONT FACE="Monospace">&quot;\x00&quot; is forbidden
in find patern in regex mode because it is the C string terminator
and is used as such by regex library). It is allowed in noregex mode.</FONT></P>
<P LANG="en-GB"><FONT FACE="Monospace">&quot;\A&quot; to &quot;\X&quot;
are not interpreted in find patern noregex mode.</FONT></P>
<P LANG="en-GB"><FONT FACE="Monospace">In noregex mode, &quot;\rIJ&quot;
s forbidden.</FONT></P>
<P LANG="en-GB"><BR><BR>
</P>
</BODY>
</HTML>