<html lang="en">
<head>
<title>Asubst</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Asubst">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#General-syntax">General syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<div align="center"><h1 class="titlefont">Asubst V12.0</h1>
</div>
<p>Asubs is a command line tool that finds occurences of text that match a pattern
(regular expresssion) and replaces these occurences by a given string.

<ul class="menu">
<li><a accesskey="1" href="#General-syntax">General syntax</a>:              General arguments of asubst. 
<li><a accesskey="2" href="#Options">Options</a>:                     Command line arguments. 
<li><a accesskey="3" href="#Environment">Environment</a>:                 Environment variables. 
<li><a accesskey="4" href="#Find-pattern">Find pattern</a>:                Syntax of the "find pattern" argument. 
<li><a accesskey="5" href="#Exclusion-pattern">Exclusion pattern</a>:           Use of exclusion pattern. 
<li><a accesskey="6" href="#Match-range">Match range</a>:                 Specify the range of patterns to substitute. 
<li><a accesskey="7" href="#Delimiter">Delimiter</a>:                   Specify a different (or no) delimiter. 
<li><a accesskey="8" href="#Replace-string">Replace string</a>:              Syntax of the replacement string. 
<li><a accesskey="9" href="#Grep-mode">Grep mode</a>:                   Display matching text only (no substitution). 
<li><a href="#Regex-and-noregex-modes">Regex and noregex modes</a>:     Differences in find pattern between both modes. 
<li><a href="#File-list">File list</a>:                   List the files to process in a file. 
<li><a href="#Exit-code">Exit code</a>:                   Meaning of Asubst exit code. 
<li><a href="#Troubleshooting">Troubleshooting</a>:             Explanation of most common issues. 
</ul>

<div class="node">
<a name="General-syntax"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Options">Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 General syntax</h2>

<pre class="example">Usage: asubst [ { &lt;option &gt; } ] &lt;find_pattern&gt; &lt;replace_string&gt; [ { &lt;file&gt; } ]
or   : asubst -h | --help | -V | --version<br>
</pre>
<p>Substitutes strings in files.<br>
If no file name is specified, substitutes from stdin to stdout.
<pre class="sp">

</pre>
See "man 3 pcre" for Perl Compatible Regular Expressions and "man 1 perlre"
for Perl Regular Expressions.

<div class="node">
<a name="Options"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Environment">Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#General-syntax">General syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Options</h2>

<pre class="example">-a or --ascii : consider that input flow or file is pure ASCII,
-D &lt;string&gt; or --delimiter=&lt;string&gt; for a delimiter other than '\n',
-d or --dotall for allow '.' to match '\n', when -D is set,
-e &lt;pattern&gt; or --exclude=&lt;pattern&gt; for skip text matching &lt;pattern&gt;,
-F &lt;file&gt; or --file_list=&lt;file&gt; to provide a file list of file names,
-f or --file for display file name in grep mode,
-g or --grep : print matching text as grep would do (no substitution),
-i or --ignorecase : do case insensitive match checking of &lt;find_pattern&gt;,
-l or --line for display line number in grep mode,
-m &lt;range&gt; or --match=&lt;range&gt; for substitution of only &lt;range&gt; matches,
-n or --number : print number of substitutions per file,
-p &lt;dir&gt; or --tmp=&lt;dir&gt; : directory of temporary files,
-q or --quiet : no printout,
-s or --save : make a copy (&lt;file&gt;.asu) of original file(s),
-t or --test for test, substitutions not performed,
-u or --utf8 : process utf-8 sequences,
-v or --verbose : print each substitution and its line number,
-x or --noregex : &lt;find_pattern&gt; is considered as string(s),
-- : to stop the list of options. If &lt;find_pattern&gt; is "-pat", then use
     asubst [ { &lt;option&gt; } ] -- "-pat" &lt;replace_pattern&gt;  [ { &lt;file&gt; } ].
</pre>
<div class="node">
<a name="Environment"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Find-pattern">Find pattern</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Options">Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Environment</h2>

<p>If the LANG environment variable is set to something containing "UTF-8", then
asubst considers that input flow or file is coded in Utf-8. This setting can be
altered in a way or the other by setting ASUBST_UTF8 environment variable
to Y, yes, N or no (with whatever casing). Finally, this setting can be
altered in a way or the other by the options -a (&ndash;ascii), or -u (&ndash;utf8).<br>
	<br>
If ASUBST_DEBUG environment variable is set to Y or yes (with whatever casing)
then asubst puts on stderr some debugging information.

<div class="node">
<a name="Find-pattern"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Exclusion-pattern">Exclusion pattern</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Environment">Environment</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Find pattern</h2>

<p>&lt;find_pattern&gt;   ::= &lt;regex&gt; | &lt;multiple_regex&gt;<br>
&lt;multiple_regex&gt; ::= { [ &lt;regex&gt; ] \n } [ &lt;regex&gt; ]<br>
<pre class="sp">

</pre>
If there is no "\n", then the regex can be any regular expression. If it
does not start with '^' nor ends with '$', then it is applied several times
to each input line (each time to the text following previous substitution).<br>
Significant '^' and '$' (not backslashed nor in brakets) are then only allowed
respectively at the beginning and at the end of the regex.<br>
Examples:
<pre class="example">echo "toto" | asubst "t" "x"   -&gt;  "xoxo"
echo "toto" | asubst "t" "ti"  -&gt;  "tiotio"
echo "tito" | asubst "t." "tu" -&gt;  "tutu"
</pre>
<p><br>
If there are "\n", they delimit several regex that will apply to several lines.<br>
Search pattern is split into several regex and \n patterns, each line of input
is split in two input items: text (possibly empty) then newline. Pattern 1 will
be compared to item 1, if they match, pattern 2 will be compared to item 2...<br>
Examples:
<pre class="example">r        -&gt; r                (r anywhere in line)
^r$      -&gt; ^r$              (line exctly matching r)
^\n      -&gt; ^$ \n            (empty line)
r1\nr2\n -&gt; r1$ \n and ^r2$
r1\nr2   -&gt; r1$ \n and ^r2
r1\nr2$  -&gt; r1$ \n and ^r2$
r1$\n     is forbdidden.
</pre>
<p><br>
The difference between "r1\n" and "r1$" is that "r1\n" is two regex. With "r1\n",
the string matching "r1" AND the following New_Line will be substituted. With
"r1$", only the string matching "r1" will be subtituted. In short, "r1\n" means
"r1 then a newline" while "r1$" means "r1, followed by a newline".<br>
<pre class="sp">

</pre>
The following specific '\' sequences are also handled:<br>
- "\i", i from 1 to 9, standard back reference to a matching substring,<br>
- "\s", replaced by a space,<br>
- "\t", replaced by a (horiz) tab,<br>
- "\xIJ" where IJ is an hexadecimal number (00 to FF or ff) for a byte code. 
"\x00" is forbidden in find pattern except in mode "noregex". 
Beware also that \xIJ is replaced before compiling the regex, so it cannot be
used to avoid a given character. "[a\x2Dx]" is exactly the same as "[a-x]",
and "\x0A" is exactly the same as "\n" (it will be used as regex delimiter).<br>
- The following shortcuts for character classes, to be used in regex within
brackets:
<pre class="example">     "\M" [:alnum:], "\A" [:alpha:], "\B" [:blank:], "\C" [:cntrl:],
     "\D" [:digit:], "\G" [:graph:], "\L" [:lower:], "\P" [:print:],
     "\T" [:punct:], "\S" [:space:], "\U" [:upper:], "\X" [:xdigit:].
</pre>
<p>Note that asubst does NOT check if such shortcut is within a bracket
expression or not. For example, "\M" is always replaced by "[:alnum:]" and,
out of a bracket expression, this becomes a bracket expression, meaning:
':' or 'a' or 'l' or 'n' or 'u' or 'm'.
<pre class="sp">

</pre>
Note that only "\s", "\t", "\n" and "\xIJ" are interpreted in "noregex" mode. 
Finally, beware that some regex expressions are supposed to match a "new line"
(example [:blank:] within a bracket expression) but will not match in asubst,
because the input flow/file is decomposed into lines and then each line is
compared to a regex expression.

<div class="node">
<a name="Exclusion-pattern"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Match-range">Match range</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Find-pattern">Find pattern</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Exclusion pattern</h2>

<p>If set, the &lt;exclude_regex&gt; must have the same number of regex as the
&lt;find_pattern&gt;. This option means that text matching the &lt;find_pattern&gt; but
also the &lt;exclude_regex&gt; will not be replaced. Beware that it applies to the
text matching &lt;find_pattern&gt; only.<br>
For example 'echo "toto" | asubst &ndash;exclude=toto to ti' will replace toto by
titi because each matching "to" does not match the exclusion "toto".<br>
On the other hand, 'echo "toto" | asubst &ndash;exclude=to to ti' and
'echo "toto" | asubst &ndash;exclude=toto toto titi' will not substitute.

<div class="node">
<a name="Match-range"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Delimiter">Delimiter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Exclusion-pattern">Exclusion pattern</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Match range</h2>

<p>The &lt;range&gt; has the format: i-j,k-l... Example: "-4,7-9,15-" means the first 4
matching occurence, the 7th to the 9th and 15th occurence and after ("" means
none). Only these occurences of matching (in the file or flow) will be
substituted.<br>
Because of the rules for parsing arguments, a &lt;range&gt; starting by '-' requires
the long option name. Example: don't use '-m -4', but '-m 1-4' or '&ndash;match=-4'.

<div class="node">
<a name="Delimiter"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Replace-string">Replace string</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Match-range">Match range</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Delimiter</h2>

<p>Normally, asubst reads the input flow or file line by line (separated by '\n')
and searches for matches between the input sequences of text and the sequence
of regex of find_pattern. However, when an input delimiter is specified (option
-D or &ndash;delimiter) then asubst reads sequences of text separated by this
delimiter (the whole text if delimiter is empty). The delimiter string is not
a regular expression but can contain "\s", "\t", "\xIJ" (even "\x00") and "\n".<br>
If a delimiter is specified, then the find pattern cannot contain '^' or '$'
and it applies to each chunk. Still, it can contain '\n' to denote line feed
within a chunk. Option -d (&ndash;dotall) can then be used to allow '.' in find
pattern to match '\n' in the text.<br>
Examples:<br>
Remove comments (and possible trailing new_line) from a XML file:<br>
asubst -D &rdquo; '&lt;!&ndash;([^-]|-[^-])*&ndash;&gt;\n?' &rdquo; file
<pre class="sp">

</pre>
Tag duplicated words in paragraphs (separated by two '\n'):<br>
asubst -D '\n\n' &ndash; '\b([\M]+)\b[\S]+\1' '-&gt;\R01&lt;-' file

<div class="node">
<a name="Replace-string"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Grep-mode">Grep mode</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Delimiter">Delimiter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Replace string</h2>

<p>The following '\' sequences are supported:<br>
- "\n" will be replaced by a newline.<br>
- "\t" will be replaced by a (horiz) tab.<br>
- "\xIJ" where IJ is an hexadecimal number (00 to FF or ff) will be replaced
by a byte with the corresponding value. 
- "\iIJ", "\aIJ", "\oIJ", "\e" and "\f" to replace by the &lt;text&gt; following it,
if Jth substring of the Ith regex matches (\rIJ not empty).<br>
The logic is a sequence of if... [ { elsif... } ] [ else... ] [ endif ]. 
Each 'if' or 'elsif' must start with a "\iIJ", possibly immediately followed
by one or several "\aIJ" or "\oIJ" evaluated one after the other. 
Example: "\i11\o12\a13T1\i13T2\eT3\f" means: If sub11 matches or sub12 matches
and sub13 matches, then replace by T1, elsif sub13 matches, then replace by
T2, else replace by T3.<br>
&lt;text&gt; ends when encountering another "\i", a "\e" or a "\f". 
- "\RIJ" where IJ is an hexadecimal number will be replaced by the string
matching the regex number IJ, (00 &lt;= IJ &lt;= NbOfRegex, 00 means the whole
string matching all regex).<br>
- "\rIJ" where IJ is an hexadecimal number will be replaced by the string
matching the substring J of the regex number I (0 &lt; I), J = 0 for the
complete string, (so "\R0x" = "\rx0").<br>
- "\K"&lt;shell command&gt;"\k", within which "\RIJ" and "\rIJ" are first replaced,
then the command is launched (and must exit with 0), then the command
directive is replaced by the command output.<br>
- "\P"&lt;file path&gt;"\p",  within which "\RIJ" and "\rIJ" are first replaced,
then the content of the file is inserted as is.<br>
- "\u", "\l", "\m" for starting an UPPER, lower or Mixed case conversion. "\c"
for stopping a case conversion. A conversion ends when a new starts, on "\c"
or at the end of replace string.
<pre class="sp">

</pre>
Note that substrings are numbered in the order of the opening parenthesis, left
to right.<br>
Note that "\r0i" and "\i0i" are forbidden.<br>
Conditions apply first, then replacement, then case conversion.
<pre class="sp">

</pre>
Examples:
<pre class="example">echo -en "toto" | asubst "t" "\x40"                     -&gt;  "@"
echo -en "toto\ntiti\ntata\n" | asubst ".*\n" "\R01"    -&gt;  "tototititata"
echo -en "\ntoto\ntiti\ntata" | asubst "\n.*" "\R02"    -&gt;  "tototititata"
echo -en "tito" | asubst "(.i)(.o)"  "\r12&lt;-&gt;\r11"      -&gt;  "to&lt;-&gt;ti"
echo -en "tito" | asubst ".*" "\m\R01"                  -&gt;  "Tito"
echo -en "toto\ntiti\n" | asubst "to\nti" "\u\R00"      -&gt;  "toTO\nTIti\n"
echo -en "toto" | asubst "(.)(.)(..)" "\u\r12\c\r11"    -&gt;  "Otto"
</pre>
<div class="node">
<a name="Grep-mode"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Regex-and-noregex-modes">Regex and noregex modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Replace-string">Replace string</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Grep mode</h2>

<p>In grep mode, asubst only looks for find_pattern and displays result,
(possibly with the input file name and possibly with the line number in this
input file) but does not alter the files.<br>
As a consequence, grep mode imposes quiet, test and no-backup modes. File_name
and line_nb modes are allowed in grep mode only, and line_nb mode requires
file_name mode.<br>
Note that it is possible to get the result of "grep -l &lt;pattern" with simply
"asubst -t &lt;pattern&gt; &rdquo;".<br>
It is possible to provide a non empty replace_string (if file_name mode is not
active), so that asubst displays it. Of course, this is especially useful if it
contains some "\RIJ" or "\rIJ".
<pre class="sp">

</pre>
Examples:
<pre class="example">echo -en "toto" | asubst -gl "toto" ""                  -&gt; toto
echo -en "toto" | asubst -g "toto" "found"              -&gt; found
echo -en "*cs add" | asubst -g "^\*([^ ]+) " "Got \r11" -&gt; Got cs
</pre>
<div class="node">
<a name="Regex-and-noregex-modes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#File-list">File list</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Grep-mode">Grep mode</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Regex and noregex modes</h2>

<p>In both modes "\x0A" is the same as "\n", and "\s" and "\t" are interpreted.<br>
In regex mode "\x00" is forbidden in find pattern because it is the C string
terminator and it is used as such by regex library.<br>
It is allowed in noregex mode.<br>
In noregex mode "\A" to "\X" are not interpreted, like other regex specific
characters (including "^" and "$").<br>
In noregex mode, "\rIJ" with J &gt; 0 is forbidden (no substring).

<div class="node">
<a name="File-list"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Exit-code">Exit code</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Regex-and-noregex-modes">Regex and noregex modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">11 File list</h2>

<p>Option -F &lt;file_list&gt; or &ndash;file_list=&lt;file_list&gt; allows specifying a file that
contains the list of files to process, instead of specifying these files as
arguments. In this case no &lt;file&gt; argument is accepted.<br>
The &lt;file_list&gt; must contain one file name per line and empty lines are skipped
(so it is impossible to specify stdin in the file list).<br>
"-" as &lt;file_list&gt; denotes stdin.<br>
Examples:<br>
asubst -F list toto titi<br>
echo -e "file1\nfile2" | asubst -F - toto titi

<div class="node">
<a name="Exit-code"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Troubleshooting">Troubleshooting</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#File-list">File list</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">12 Exit code</h2>

<p>Asubst exits with 0 if some matching was found, with 1 if no matching
was found, with 2 otherwise (e.g. in case of error). It can also exit with code
3 if stopped (Ctrl-C or SIGTERM) while executing external command, or with
standard 128 + signal number.

<div class="node">
<a name="Troubleshooting"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Exit-code">Exit code</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">13 Troubleshooting</h2>

<p>- Asubst is stuck. -&gt; Maybe an argument is missing or an option is not complete,
and asubst is waiting in stdin.<br>
e.g. "asubst -m 5 6 file". Asubst considers "5" as the value for m, "6" as the
find_pattern and "file" as the replace_string, so no file name is provided.
<pre class="sp">

</pre>
- I want to substitute "\f", why do I need to provide "\\\\f"? -&gt; Because regex
imposes to provide "\\f" for matching "\f", ("\f" matches "f") and the shell
imposes a "\\" for each "\" transmitted to asubst.<br>
Note that, you can pass to the shell '\\f' instead of "\\\\f".<br>
Same considerations apply to "\$" or '$' in order to pass '$' to asubst.
<pre class="sp">

</pre>
- ERROR: Cannot create temp file in ".".  -&gt; Asubst cannot make the temporary
file, probably because the file system does not support hard links (e.g. samba
file system). Try the -p (&ndash;tmp) option with a UNIX directory.
<pre class="sp">

</pre>
- The 'else' part of the condition is not processed. -&gt; The whole replace string
is not processed if the input text does not match the find pattern. Example,
with '([A-Z][a-z])|([0-1])' '\i11Letter\i12Digit\eOther\f' the input text '!' 
remains unchanged. Appending '|.' to the search pattern makes it match and be
substituted by 'Other'.

</body></html>

