tcpchat
=======
V2.5

Tcpchat accepts connections on a TCP port, expects specific sentences and
executes specified actions depending on what it receives.

Presentation
------------

General description
~~~~~~~~~~~~~~~~~~~
tcpchat takes 2 arguments: a TCP port name or number and a chats file name.

It listens on the port and accepts one TCP connection at a time: new
connections are not accepted while one client is connected.

It expects to receive one or several sentences (a sentence is one line
terminated by Lf), it executes some actions and replies by one or several
sentences.

Chat file and behavior
~~~~~~~~~~~~~~~~~~~~~~
.File
The chats file defines the version and describes several alternative chats.

.Chat
Each chat starts with one expected sentence followed by a script of expected
sentences and/or actions.

A chat has a unique name. It can define a global timeout for its execution
(default is infinite) and a default timeout for all its statements where an
input is expected: 'select', 'read' and 'skip' (default is infinite).

A chat defines a pattern that will lead it to be selected (and the script
to be executed) if the input string matches the pattern (string comparison or
regular expression matching). The input is tested versus each patterns
successively until one matches.

In case of a regexp, some xref:Variables[Variables] can be defined and
initialized from the content (or a part) of the input string.

.Statements
Once the chat is selected, tcpchat executes one after the other the statements
of the script:

- 'select': A select is like a sub-chat but with no name. It
allows selecting a subscript according to the reception of a matching
sentence. 
 * If the select has a default entry then this entry is selected when the
sentence does not match any of the expected strings.
 *  If is has a timeout defined and a timeout entry then this entry is selected
if no sentence has been received when the timeout expires.

- 'cond': execute a sub-script on condition (if a variable matches a criteria,
elsif...  else...).
- 'repeat': loop executing a sub-script while a condition is true.
- 'read': Read next sentence and check that it matches the one provided. 
On option, fails on timeout if no input is received before a timeout
expiration.
- 'skip': Read next sentence, whatever it is, with an optional timeout.
- 'wait': Wait the specified delay.
- 'send': Send the sentence provided, on option with a line feed.
- 'set': Set a variable to the result of an evaluated expression.
- 'assign': Same as 'set' but catches and handles evaluation error.
- 'call': Call the shell to execute the command and arguments provided. Send
the output flow of the command, optionnaly catches and handles error.
- 'eval': Call the shell to execute the command and arguments provided. Set a
variable to the output flow of the command, optionnaly catches and handles
error.
- 'chdir': Change current directory until another chdir or until a script ends
on xref:Close[close] or xref:Failure[failure], optionnaly catches and handles
error. With an empty argument, move back to the original directory when
tcpchat has been launched. 
- 'log': Report some text on stderr.
- 'close': Close current chat, go back to chat selection.

.Script end
When a subscript reaches its end, the execution continues at the statement
following the one that lead to this subscript (if any).

A chat script ends on either:

- nothing else to do: Keep connection open and go back expecting a chat
selection. Variables and current dir are not reset. The chat
timeout, if any, remains active until a new chat is selected.
- anchor:Close[]a 'close' statement: Close current connection, reset variables
and current dir, and go back expecting a chat selection.
- anchor:Failure[]a failure: one of the following situations, which leads to
the closure (as on statement 'xref:Close[close]') of current script:
 * The expiration of the timeout global to the chat script.
 * The expiration of the timeout on the whole chats selection, on a read, on a
skip, or on a select when it has no 'timeout' entry.
 * The reception of a non expected string by a 'read'.
 * The reception of a non expected string by a 'expect' (for 'chats' or
'select') when it has no 'default' entry.
 * A transmission error (closure, overflow).
 * The failure of 'call' or 'eval' of an external command if there is no
'error' entry to handle the failure.
 * An invalid expression (including invalid computation, reference to an
 undefined variable...) in a 'set' statement
 * An undefined variable in a statement 'if', 'elsif', 'while' with the IfUnset
attribute set (or left) to "error".
 * Error of 'chdir' when changing current directory if there is no 'error'
entry to handle the failure.

anchor:Variables[]

.Variables
The text of sentences that are expected, read or sent, the text of commands that
are called or executed, and the text of expressions that evaluated, can
reference variables. Variables obey to the following rules:

- Assignments (after 'chat', 'read' or 'expect') have the form "VAR=... VAR=..."
- 'set', 'assign' and 'eval' statements directly assign a variable
- References have the form $\{name} where:
  * $\{0} denotes the full string matching the regexp
  * $\{1} to $\{9} denote the substrings (matching "(...)" in the regexp)
  * ${$name} denotes a ENV variable
  * Internal variables names cannot be numbers nor start by "$" nor contain "="
  * 'set' and 'assign' with the "Compute" attribute set convert an expression
(possibly referring to variables) to an integer and back to a string stored in
a variable
  * 'set', 'assign' and 'eval' with the "OnlyIfNotSet" attribute set, assign the
variable only if is not defined yet
  * 'if', 'elsif' and 'while' with the variable not set may raise error or may
return true or false depending on the "IfUnset" attribute.

Any occurrence of "${" or "}" that doesn't denote a variable must be
backslashed.

It is an error if a variable does not exist when it is referenced in an
expression. In case of 'assign' statement this error can be caught and handled.

A computed expression must be a valid combination of variables, values,
 operations and parentheses, otherwise this is an error. In case of 'assign'
statement this error can be caught and handled.

.Pattern matching
The text of 'chat', 'expect' and 'read' statements is by default considered as
the string  with witch the input sentence must be equal. On option it can be
considered as a regular expression pattern with the input sentence must
completely match (i.e. <input_string> matches "^<regex>$").

High level design
-----------------
General design
~~~~~~~~~~~~~~
There are 4 main modules:

- IOs in charge of managing the TCP connections (accepting, closing,
sending, receiving). Reception is coupled with an input buffer to
provide sentences.
+
Cr are removed if sentence ends with CrLf.
+
API is: init, wait, read, send, reset and close. Read takes a timeout
and returns either a timeout event or a sentence. Wait takes a timeout.
Timeouts can be infinite. Wait, read and send can raise/return Disconnection.

- Tree in charge of storing the tree of chat scripts events and actions.

- Matcher in charge of checking if an event matches a node of the tree.

- Events in charge of navigating in the tree, waiting for events and
executing the actions.

There are 3 main steps of execution:

a. Parsing the xml file into our own tree. Raise init fatal errors.

b. Accepting connections. Raise init fatal errors

c. Main loop: Event => action

Design of the tree
~~~~~~~~~~~~~~~~~~
Each node of the tree contains:

- Kind (Enum): Selec, Read, Default, Timeout, Skip, Wait, Send, Call, Close.
Chat and expect statements are mapped as Read nodes, children of a Selec.
Assign statements are Set statements.

- Name (Asu_Us): For a chat, its name

- Text (Asu_Us). For a Read the sentence expected, for a Send/Call/ the
sentence to send, for a Call the command and arguments to invoke.
Chats is a Selec, chat is an expect, expect is mapped as a Read (child
of a Selec)

- Timeout (Ms). For a Selec (including chats) a read or skip it's a
failure if it expires (no matching / not matching / nothing received).
+
For a chat it's a failure if it expires before the end of the chat. For
a Wait it is the delay to wait. Note that the chat InputDefaultTimeoutMs
is not stored in the tree. It is kept in memory (while building the
tree) and set in the Selec/Read/Skip nodes that have no timeout defined.

- Next: The reference to the node that implements the following of the
script: It is the statement following the current statement if there is
one.  Otherwise, it is the statement following ancestor select...  Close
has no Next. Other nodes have at least Next pointing to the chats node
(root).
+
Ex: Selec1 has 2 Expects and is followed by a Read. Expect1 leads to
Select11 that is not followed. Expect2 leads to Select21 that is
followed by a Wait. Branches of Select11 end with Next=Read, while
branches of Selec21 end with Next=Wait. Branch of the Read ends with
Next=Root.

Nodes, children, Next:

- Root is a Selec node (the chats statement) with no Next

- A node of kind Close has no child and no Next

- A Selec node has one (Read) child for each of its chat or expect, then
possibly one (Default) child for the default, then possibly one (Timeout) child
for handling the timeout, then possibly a child: the next statement following
the select (in this case, Next points to it).

- A Set node can have 2 children (when it is an assign statement). In this case
the first child is the first instruction handling the error.

- A Call or Chdir node have 2 children, the first of which is the
first instruction handling the error.

- Other nodes may have one child: the statement following current (in this
case, Next points to it) or no child (in this case, Next points to the
same node as the first non null Next of a parent Selec, or ultimately to
root).

- Statements chat and expect are mapped as Read nodes.

- Statement assign is mapped as Set nodes.

Parsing of the tree
~~~~~~~~~~~~~~~~~~~
First the Xml file is parser with Xml_Parser.

Then the tree is build by navigating through the XML tree with a recursive
operation that creates nodes with Kind, Text, and Timeout.

- Kind: see above

- Name: see above

- Text: ENV variables are expanded, possibly leading to error.
When parsing a "chat" XML node, a global variable is set to the default
timeout it defines or infinite. When parsing a select, read or skip, local
timeout is set to local value if defined, or to the global default.
+
After creating a Selec node, its Next is set to its last child if it is the
statement following the select, and to null otherwise.

Then a second pass calls a recursive operation, passing to it Next initialized
to root. When arriving on a Selec node, the local Next, if null, is set to the
value received. The local Next is passed recursively when parsing children.
When arriving on a node with no child, set it Next to the value receive if it
type is not Close.

Main loop
~~~~~~~~~
Depending on the type of current node:

- Select (including root): Read text. Check if it matches a child or default.
Jump to it.

- Condition: Check if it matches a child. Jump to it.

- Repeat: Check if it matches a child. Jump to first statement to repeat
or to the next node after the loop.

- Read: Read text. Check that it matches the expected text. Jump to next
node or reset.

- Skip: Read text and discard. Jump to next node.

- Wait: Wait the delay. Jump to next node.

- Send: Expand the text and send it. Jump to next node.

- Call: Issue the command. Jump to next node.

- Eval: Issue the command and evaluate the result. Jump to next node.

- Set: Evaluate the variable. Jump to next node.

- Assign: Evaluate the variable. Jump to next node.

- Chdir: Change current directory. Jump to next node.

- Log: Log message on stderr. Jump to next node.

- Close: Reset connection and jump to the root of the tree.


