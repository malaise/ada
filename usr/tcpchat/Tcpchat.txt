tcpchat
=======
V4.0

Tcpchat accepts connections on a TCP port, expects specific sentences and
executes specified actions depending on what it receives.

Presentation
------------

General description
~~~~~~~~~~~~~~~~~~~
tcpchat takes 2 arguments: a TCP port name or number and a chats file name.

It listens on the port and accepts one TCP connection at a time: new
connections are not accepted while one client is connected.

It expects to receive one or several sentences (a sentence is one line
terminated by Lf), it executes some actions and replies by one or several
sentences.

Chat file and behavior
~~~~~~~~~~~~~~~~~~~~~~
.File
The chats file defines the version and describes several alternative chats
scripts.

.Chat
Each chat starts with one expected sentence followed by a script of expected
sentences and/or actions.

A chat has a unique name. It can define a global timeout for its execution
(default is infinite) and a default timeout for all its statements where an
input is expected: 'select', 'read' and 'skip' (default is infinite).

A chat defines a pattern that will lead it to be selected (and the script
to be executed) if the input string matches the pattern (string comparison, 
regular expression matching or integer comparison). The input is tested versus
each pattern successively until one matches.

In case of a regexp, some xref:Variables[Variables] can be defined and
initialized from the content (or a part) of the input string.

.Statements
Once the chat is selected, tcpchat executes one after the other the statements
of the script:

- 'select': A select is like a sub-chat but with no name. It
allows selecting a subscript according to the reception of a matching
sentence. 
 * If the select has a default entry then this entry is selected when the
sentence does not match any of the expected strings.
 *  If is has a timeout defined and a timeout entry then this entry is selected
if no sentence has been received when the timeout expires.

- 'cond': execute a sub-script on condition (if a variable matches a criteria,
elsif...  else...).
- 'while': loop executing a sub-script while a condition is true.
- 'read': Read next sentence and check that it matches the one provided. 
On option, fails on timeout if no input is received before a timeout
expiration.
- 'skip': Read next sentence, whatever it is, with an optional timeout.
- 'wait': Wait the specified delay.
- 'send': Send the sentence provided, on option with a line feed.
- 'set': Set a variable to the result of an evaluated expression.
- 'assign': Same as 'set' but catches and handles evaluation error.
- 'parse': Evaluate an expression, parse it accordig to a regexp and assign
variables.
- 'call': Call the shell to execute the command and arguments provided. Send
the output flow of the command, optionnaly catches and handles error.
- 'eval': Call the shell to execute the command and arguments provided. Set a
variable to the output flow of the command, optionnaly catches and handles
error.
- 'chdir': Change current directory until another chdir or until a script ends
on xref:Close[close] or xref:Failure[failure], optionnaly catches and handles
error. With an empty argument, move back to the original directory when
tcpchat has been launched. 
- 'log': Report some text on stderr.
- 'close': Close current chat, go back to chat selection.

.Script end
When a subscript reaches its end, the execution continues at the statement
following the one that lead to this subscript (if any).

A chat script ends on either:

- nothing else to do: Keep connection open and go back expecting a chat
selection. Variables and current dir are not reset. The chat
timeout, if any, remains active until a new chat is selected.
- anchor:Close[]a 'close' statement: Close current connection, reset variables
and current dir, and go back expecting a chat selection.
- anchor:Failure[]a failure: one of the following situations, which leads to
the closure (as on statement 'xref:Close[close]') of current script:
 * The expiration of the timeout global to the chat script.
 * The expiration of the timeout on the whole chats selection, on a read, on a
skip, or on a select when it has no 'timeout' entry.
 * The reception of a non expected string by a 'read'.
 * The reception of a non expected string by a 'expect' (for 'chats' or
'select') when it has no 'default' entry.
 * A transmission error (closure, overflow).
 * The failure of 'call' or 'eval' of an external command if there is no
'error' entry to handle the failure.
 * An invalid expression (including invalid computation, reference to an
 undefined variable...) in a statement
 * Error of 'chdir' when changing current directory if there is no 'error'
entry to handle the failure.

anchor:Variables[]

.Variables
The text of sentences that are expected, read or sent, the text of commands that
are called or executed, and the text of expressions that evaluated, can
reference variables. Variables obey to the following rules:

- Assignments (after 'chat', 'read', 'expect' or 'parse') have the form
"VAR=... VAR=..."
- 'set', 'assign' and 'eval' statements directly assign a variable
- References have the form $\{name} where:
  * $\{0} denotes the full string matching the regexp
  * $\{1} to $\{9} denote the substrings (matching "(...)" in the regexp)
  * ${$name} denotes a ENV variable
  * Internal variables names cannot be numbers nor start by "$" nor contain "="
  * 'set' and 'assign' with the "Compute" attribute set convert an expression
(possibly referring to variables) to an integer and back to a string stored in
a variable
  * 'set', 'assign' and 'eval' with the "OnlyIfNotSet" attribute set, assign the
variable only if is not defined so far.

Any occurrence of "${" or "}" that doesn't denote a variable must be
backslashed.

It is an error if a variable does not exist when it is referenced in an
expression. In case of 'assign' statement this error can be caught and handled.

A computed expression must be a valid combination of variables, values,
operations and parentheses, otherwise this is an error. In case of 'assign'
statement this error can be caught and handled.

.Pattern matching and integer matching
The criteria of 'chat', 'expect', 'read', 'if', 'elsif', 'while' and 'read'
statements is by default considered as the string  with witch the input
sentence or expression must be equal ('Oper'="=") or from which it must be
different ('Oper'="/="). +
On option it can be considered as as the regular expression pattern with 
which the input sentence must completely match (i.e. <input_string>
matches "^<regex>"") ('Oper'="=") or with which it  must not match
('Oper'="/="). +
Alternatively, on option, the criteria and the input (or the expression) are
computed and compared through the operator ("=", "/=", "<", ">", "<=" or
">=").

High level design
-----------------
General design
~~~~~~~~~~~~~~
There are 4 main modules:

- IOs in charge of managing the TCP connections (accepting, closing,
sending, receiving). Reception is coupled with an input buffer to
provide sentences.
+
Cr are removed if sentence ends with CrLf.
+
API is: init, wait, read, send, reset and close. Read takes a timeout
and returns either a timeout event or a sentence. Wait takes a timeout.
Timeouts can be infinite. Wait, read and send can raise/return Disconnection.

- Tree in charge of storing the tree of chat scripts events and actions.

- Matcher in charge of checking if an event matches a node of the tree.

- Events in charge of navigating in the tree, waiting for events and
executing the actions.

There are 3 main steps of execution:

a. Parsing the xml file into our own tree. Raise init fatal errors.

b. Accepting connections. Raise init fatal errors

c. Main loop: Event => action

Design of the tree
~~~~~~~~~~~~~~~~~~
Each node of the tree contains:

- Kind (Enum): Selec, Expect, Default, Timeout, Cond...
Chats statment is the only Selec node with no father. Chat statements are
Expect nodes with A name.

- Name (Asu_Us): For a chat, its name

- Critext (Asu_Us). For a Read the sentence expected, for a Send/Call/ the
sentence to send, for a Call the command and arguments to invoke.

- Expression. For a Condif, Repeat, Set or Assign, the expression to compute.

- Timeout (Ms). For a Selec (including chats) a read or skip it's a
failure if it expires (no matching / not matching / nothing received).
+
For a chat it's a failure if it expires before the end of the chat. For
a Wait it is the delay to wait. Note that the chat InputDefaultTimeoutMs
is not stored in the tree. It is kept in memory (while building the
tree) and set in the Selec/Read/Skip nodes that have no timeout defined.

Nodes, children, Next:

- Root is a Selec node (the chats statement) with no Next

- A node of kind Close has no child and no Next

- A Selec node has one Expect child for each of its chat or expect, then
possibly one (Default) child for the default, then possibly one (Timeout) child
for handling the timeout.

- A Set node can have  children (when it is an assign statement). In this case
they are the instructions handling the error.

- A Call or Chdir node can have children, the instructions handling the error.

- A Repeat node usually has children that are the instructions of the
repeated block.

- A Cond node has a child for each Condif and Condelse. Each of them usually
has children that are the instructions of the alternative block.


- Other nodes have no child.

Parsing of the tree
~~~~~~~~~~~~~~~~~~~
First the Xml file is parser with Xml_Parser.

Then the tree is build by navigating through the XML tree with a recursive
operation that creates nodes with Kind, Critext, Expression and attributes.

- 
When parsing a "chat" XML node, a global variable is set to the default
timeout it defines or infinite. When parsing a select, read or skip, local
timeout is set to local value if defined, or to the global default.

Main loop
~~~~~~~~~
Depending on the type of current node:

- Select (including root): Read text. Check if it matches a child or default.
Jump to it.

- Condition: Check if it matches a child. Jump to it.

- Repeat: Check if it matches a child. Jump to first statement to repeat
or to the next node after the loop.

- Read: Read text. Check that it matches the expected text. Jump to next
node or reset.

- Skip: Read text and discard. Jump to next node.

- Wait: Wait the delay. Jump to next node.

- Send: Expand the text and send it. Jump to next node.

- Call: Issue the command. Jump to next node.

- Eval: Issue the command and evaluate the result. Jump to next node.

- Set: Evaluate the variable. Jump to next node.

- Assign: Evaluate the variable. Jump to next node.

- Parse: Parse the expression. Jump to next node.

- Chdir: Change current directory. Jump to next node.

- Log: Log message on stderr. Jump to next node.

- Close: Reset connection and jump to the root of the tree.

