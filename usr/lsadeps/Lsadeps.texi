\input texinfo.tex    @c -*-Lsadps-*-
@c %**start of header
@setfilename Lsadeps
@settitle Lsadeps
@c %**end of header

@c Constants
@set name lsadeps
@set version V7.3
@set nameversion @value{name} @value{version}

@c General format
@paragraphindent none
@exampleindent 0

@c Title and front page
@node Top
@ifhtml
@center @titlefont{@value{nameversion}}
@end ifhtml
@ifnothtml
@top @center @value{nameversion}
@end ifnothtml

Lsadeps lists ada dependencies between files or units, optionnally in reverse order.@*
Alternatively it checks redundants "with" clauses between specs and bodies.
@menu
* Usage::             Command line arguments.
* Output::            Format of output.
* Examples::          Examples
* Design::            High level design.
@end menu

@node Usage, Output, Top, Top
@chapter Command line arguments

@verbatim
Usage: lsadeps <version> | <help> | <check> | <depend>
 <version>     ::= -v | --version
 <help>        ::= -h | --help
 <check>       ::= -c | --check  [ <target_dir> ]
 <depend>      ::= <options> <target_unit> [ <path_unit> ]
 <target_unit> ::=  [<path>/]<unit>
 <options>     ::=  [ <specs> | <revert> ] [ <tree> ] [ <files> ] [ <include> ]
 <specs>       ::= -s | --specs
 <revert>      ::= -r | --revert
 <tree>        ::= -t | --tree
 <files>       ::= -f | --files
 <include>     ::= { <dir> | <recursive> }
 <dir>         ::= -I <dir> | --include=<dir>
 <recursive>   ::= -R <dir> | --recursive=<dir>
Check function shows redundant "with" clauses in a dir (default: current dir).
Dependency function by default lists units on which <target_unit> depends,
    which are withed units, their body and subunits, units withed by these
    units... recursively. Alternative modes are:
 <specs> to show only units withed by specs and standalone bodies,
 <revert> to show units withing <target_unit>... recursively.
 <path_unit> to show dependency paths between two units.
 Other options are:
 <tree> to show the tree of dependencies (instead of a sorted unique list),
 <file> to show the file names (instead of unit names),
 <include> to add some directories or some directory trees to the search path
   (default is current and target directories).
@end verbatim
@*
Check mode does not support options (even includes), only one optional target
directory.@*
Specs and revert modes are mutually exclusive.@*
Path mode and tree are mutually exculsive.@*

@node Output, Examples, Usage, Top
@chapter Format of output
There are two main functions: list dependancies and check redundant "with"
@section Show dependancies
There are 4 different modes of analyse of dependancies (that can be combined)
and 2 options of output:
@itemize @minus
@item default mode: show parent units of target, then withed units, then
body and subunits... recusively
@item specs mode: same as default but only show units withed by specs
@item revert mode: show units withing target, then units withing them...
recusively
@item path mode: shows the units withed by (or withing) each other between
two units
@item tree option: show tree of dependencies instead of list
@item files option: show file names instead of units
@end itemize

in list mode local units are listed first, then "remote" ones in the order of
the include directives and they are sorted by alphapbetical order.
in tree mode the units appear in the same order as in the "with" directives.
@sp 1
by default the search is restricted to local directory and target directory
(and path_unit directory if any), but additional directories can be added to
the search path, either individually or recursively.
@sp 1
a local unit, if any exists, hides all the remote ones.@*
example: suppose that a unit U withes a unit W.@*
in normal (non revert) mode all remote units W are discarded if there is a
unit W co-located with U.@*
in revert mode, a remote unit W withing unit U is discarded if there is another
unit U co-located with W.@*
if there is no co-located unit then all the remote units with the same name are
processed identically (they are all considered to depend on or to be dependent
from current unit).
@section Check redundant "with"
this funtion checks that no redundant "with" clause appear
in the body and sub-units of each unit.@*
lsadeps then exits with 1 if at least one redundant "with" is detected
and with 0 otherwise.

@node Examples, Design, Output, Top
@chapter Examples
@table @asis
@item What are the units needed by Unit
lsadeps Unit (or lsadeps unit)
@item What are the units, including those or the repository, needed by Unit
lsadeps -I ~/ada/reposit Unit
@item What are all the files needed to build Unit
lsadeps -f -I ~/ada/reposit Unit
@item How does Unit1 need Unit2
lsadeps Unit1 Unit2
@item What are all the units that will be re-compiled due to a modification of Unit spec
lsadeps -r -R ~/ada/usr Unit
@end table

@node Design, , Examples, Top
@chapter High level design
@section Parse and check arguments
@itemize @minus
@item in non check mode target is a unit (possibly containing a path), an
optional path_unit triggers the path analysis between the target and this unit
@item in check mode it is an optional path that denotes the directory to check
@item include dirs (recursive or not) must exist
@end itemize

@section Parse ada sources
List and parse all ada sources in current and included dirs. For each file,
store in a list:
@itemize @minus
@item kind: UnitSpec/UnitBody/SubUnit (US/UB/SU)
@item Unit_Name, Mixed_Str.
@item Path of the unit (directory where it is located)
@item File name
@item StandAlone indicator, boolean, if spec without body or body without spec
@item Unit_Name of parent (if child spec, child body or subunit)
@item List of withed unit names: @@Name@@Name...@@
@item List of used unit names: @@Name@@Name...@@
@item List of subunits names (if body or subunit): @@Name@@Name...@@
@end itemize
@*
"Path/Unit_Name#Kind" is the unique access key.
A spec, its body and its subunits must be colocated.@*
No check that withed units exist but check that target is listed (as spec or
standalone body).
Also store in a list, for each Unit_Name, the list of paths where such unit exists.

@section Check redundant "with"
For each unit build the tree of its parents (sub-unit -> body -> spec) and for
each unit make the list of its withed units.@*
For each unit U check that no withed unit W is withed twice by U or by a parent of U,
including indirect with of a child of W. Note that a redundant "with" context
clause is acceptable in case of a "use" context clause.@*
Exit program.

@section Build tree
If in normal (not reverse) mode, start from target, process dependancies
recursively in this order:
@verbatim
unit - ParentUnit
     - WithsOfSpec
     - WithsOfBody
     - WithsOfSububits
@end verbatim
If in specs only mode don't insert body andsubunits.
If in reverse mode, build a unique list of units that list targets, of units
that list these units. Stop recursive search when reaching a non-standalone
body or a subunit.

@section Display output
In unit mode, only show specs and standalone bodies, otherwise (file mode) show
all entries.@*
Iterate on tree:

@subsection In tree mode
Dump the tree:
@verbatim
UnitSpec - UnitBody - Subunits - WithSpecs
                    - WithsSpecs...
         - ParentSpec - WithsSpecs...
         - WithsSpecs - WithsSpecs...
@end verbatim
@subsection In list mode
Dump the tree in a list.@*
Sort it by unit/file path (local first).@*
In case of file revert mode, list each unit by spec+body+subunits.
@subsection In path mode
Keep track in a list of the units between target and current unit.@*
When current unit is path_unit then show the current list.

@bye

