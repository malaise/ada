lsadeps
=======
V11.2

Lsadeps lists ada dependencies between files or units, optionally in reverse
order.

Alternatively it checks redundant "with" clauses between specs and bodies.

It relies on GNAT file naming conventions:

  <unit>{[("-"|"~")<child_or_subunit>]}".ad"("s"|"b")

Command line arguments
----------------------
Usage: lsadeps <version> | <help> | <depend> | <list> | <check>

 <version>     ::= -v | --version
 <help>        ::= -h | --help
 <depend>      ::= <options> <target_unit> [ <path_unit> ]
 <target_unit> ::=  [<path>/]<unit>
 <options>     ::=  [ <specs> | <revert> ] [ <tree> | <direct> ] [ <files> ] [ <bodies> ] [ <inclusions> ]
 <specs>       ::= -s | --specs
 <revert>      ::= -r | --revert
 <tree>        ::= -t | --tree
 <direct>      ::= -d | --direct
 <files>       ::= -f | --files
 <bodies>      ::= -b | --bodies
 <inclusions   ::= { <include> | <recursive> | <exclude> }
 <dir>         ::= -I <dir> | --include=<dir_path>
 <recursive>   ::= -R <dir> | --recursive=<dir_path>
 <exclude>     ::= -E <dir> | --exclude=<dir_name>
 <list>        ::= -l | --list  [ <file> ] [ <all> ] [ <children> [ <path_unit> ]
 <all>         ::= -a | --all
 <children>    ::= -C | --children
 <check>       ::= -c | --check  [ <target_dir> ]

There are three main functions: Show dependencies, list units, and check
redundant "with".

Show dependencies
~~~~~~~~~~~~~~~~~
This function by default lists the units on which <target_unit> depends,
which are withed units, their body and subunits, units withed by these
units... recursively. +
Alternative modes are:

 - 'specs' to show only units withed by specs and standalone bodies.

 - 'revert' to show units depending on <target_unit>, which are its child
units and the units withing <target_unit>... recursively.

 - 'path_unit' to show dependency paths between <target_unit> and <path_unit>.

Other options are:

 - 'tree' to show the tree of dependencies (instead of a sorted unique list),

 - 'direct' to show only the units that are directly dependent,

 - 'file' to show the file names (instead of unit names),

 - 'bodies' to show, in revert mode, the units that depend from each other by
   "with" in the body,

 - 'inclusions' to add some directories or some directory trees to the search
path. +
By default, the files are searched only in the current directory and in the
directory of the target unit (or in the target directory itself) if any.
These options are:
  * 'include': adds an individual directory to the search path,
  * 'recursive': adds a directory and each of its subdirectories to the search
path,
  * 'exclude': adds a directory name in the list of exclusion: Any directory in
a 'recursive' search (including the root path provided as argument) that has
its name defined in the exclusion list is skipped, and its subdirectories as
well. +
Individual 'include' paths are not checked for exclusion. 

NOTE: 'include' and 'recursive' must specify directory paths (absolute or
relative), while 'exclude' must specify simple directory names (no \'/').

'Specs' and 'revert' modes are mutually exclusive. +
'Tree' and 'direct' modes are mutually exclusive. +
'path_unit' and 'direct' modes are mutually exclusive. +
'bodies' is allowed only in 'revert' mode

NOTE: By default, in 'revert' mode, if unit B is withed by the body of A (and
not by its spec), then the units withing A are not dependant from B in term of
compilation, so they are not listed. Option 'bodies' leads to list all the
revert dependecies.

NOTE: When the 'tree' option is not set, the analysis of dependencies
is optimized so that the same unit is not analyzed several times. As a
consequence, the option 'path_unit' without 'tree' leads to display only
one path between the specified units, *not necessarily the shortest*. +
Adding the 'tree' option to a 'path_unit' leads to build the whole tree of
dependancies between the specified units and to display all the possible paths
between them, which might be very time-consuming.

List units
~~~~~~~~~~
This function lists:

 * the units (including child units but not subunits) of the
current directory if no argument is provided,
 * or the units (same as above) of <path_unit> if it denotes a directory,
 * or only the unit <path_unit> if it denotes a unit.

The possible options are:

 - 'children' to list the children of the specified unit.
 - 'file' to show the file names (instead of unit names),
 - 'all' to also list the subunits (of all or of the specified unit).

Check redundant "with"
~~~~~~~~~~~~~~~~~~~~~~
This function shows redundant "with" clauses in a dir (default: current
dir), which are:

 - A body that withs a unit while this unit or a child is already withed by
the spec,
 - A subunit that withs a unit while this unit or a child is already withed by
the spec or the body,
 - A child unit that withs a unit while this unit or a child is already withed
by one of its parents. +

It does not support any option (even includes), only one optional 'target'
directory.

Ada language selection
~~~~~~~~~~~~~~~~~~~~~~
The files are parsed according to the default Ada language version 'Ada2012',
but the environment variable 'LSADEPS_LANGUAGE' can be set to 'Ada83', 'Ada95'
'Ada2005' or 'Ada2012' to tune the logic of the parsing.

Format of output
----------------

Results are put on stdout.

Show dependencies
~~~~~~~~~~~~~~~~~
There are 4 different modes of analyze of dependencies (that can be combined)
and 2 options of output:

- default mode: show parent units of target, then withed units, then body
and subunits... recursively

- specs mode: same as default but only show units withed by specs

- revert mode: show units withing target and child units of target, then units
withing them... recursively

- path mode: shows the units withed by (or withing) each other between two units

- tree option: show tree of dependencies instead of list

- direct option: show direct dependencies (show first level of tree)

- files option: show file names instead of units

In list mode local units are listed first, then "remote" ones in the order of
the include directives and they are sorted by alphabetical order. In tree
and direct modes the units appear in the same order as in the "with" directives.

By default the search is restricted to local directory and target directory
(and path_unit directory if any), but additional directories can be added to
the search path, either individually or recursively.

A local unit, if any exists, hides all the remote ones.

Example: suppose that a unit U withes a unit W.

- in normal (non revert) mode all remote units W are discarded if there is a
unit W co-located with U.

- in revert mode, a remote unit W withing unit U is discarded if there is
another unit U co-located with W.

- if there is no co-located unit then all the remote units with the same name
are processed identically (they are all considered to depend on or to be
dependent from current unit).

Lsadeps exits with 1 on error, and with 0 otherwise.

List units
~~~~~~~~~~
If <path_unit> denotes a directory, then all the units of the directory are
listed, one per line, in alphabetical order (by default not the subunits).
Otherwise the specified unit is listed (by default not its subunits).

If <path_unit> denotes a unit, option -C lists it and its child units.

Optionally the subunits are listed after each unit.

Alternatively, the corresponding files, specification then body (then,
if specified, the files of the subunits), are listed.

Lsadeps exits with 1 on error, including when no unit could be found,
and with 0 otherwise.

Check redundant "with"
~~~~~~~~~~~~~~~~~~~~~~
This function checks that no redundant "with" clause appear in the body and
sub-units of each unit.

It reports redundancy with messages like: +
"'Unit <unit> withes <withed> already withed by parent <unit>'", +
- where <unit> is the path of the unit, followed by '#', then either 'US' (Unit
Spec), 'UB' (Unit Body) or 'SU' (SubUnit) +
- and <withed> is the name of the redundant withed unit.

Example:

  Unit lsadeps/Output#UB withes Sourcer already withed by parent lsadeps/Output#US

Lsadeps exits with 1 if at least one redundant "with" is detected or on
error, and with 0 otherwise.

Examples
--------

What are the local units needed to build (compile and link) 'Unit'
--------------------
  lsadeps Unit (or lsadeps unit)
--------------------

What are the units, including those of the repository, needed to build 'Unit'
--------------------
  lsadeps -I ~/ada/reposit Unit
--------------------

What are all the files needed to build 'Unit'
--------------------
  lsadeps -f -I ~/ada/reposit Unit
--------------------

How does 'Unit1' need 'Unit2'
--------------------
  lsadeps Unit1 Unit2
--------------------

What are all the units that will be re-compiled due to a modification of
'Unit' spec
--------------------
  lsadeps -r -R ~/ada/usr Unit
--------------------

Check redundant "with" in the current directory
--------------------
  lsadeps -c
--------------------

Check if the unit 'Unit' exists in current dir
--------------------
  lsadeps -l Unit >/dev/null 2>&1; echo $?
--------------------

List all files of '../ada/Unit' and its subunits
--------------------
  lsadeps -lfa ../ada/Unit
--------------------

List Unit and all its child units
--------------------
  lsadeps -lC Unit
--------------------

High level design
-----------------
Parse and check arguments
~~~~~~~~~~~~~~~~~~~~~~~~~
- in dependency mode, target is a unit (possibly containing a path). An
optional path_unit triggers the path analysis between the target and this unit

- include dirs (recursive or not) must exist

- in check mode it is an optional path that denotes the directory to check

Parse ada sources
~~~~~~~~~~~~~~~~~
List and parse all ada sources in current and included dirs. For each file,
store in a list:

- kind: UnitSpec/UnitBody/SubUnit (US/UB/SU)

- Unit_Name, Mixed_Str.

- Path of the unit (directory where it is located)

- File name

- StandAlone indicator, boolean, if spec without body or body without spec

- Unit_Name of parent (if child spec, child body or subunit)

- List of withed unit names: @\Name@Name...@

- List of used unit names: @\Name@Name...@

- List of subunits names (if body or subunit): @\Name@Name...@

- List of the child units of this unit

"Path/Unit_Name#Kind" is the unique access key.  A spec, its body and its
subunits must be collocated in the same directory.

No check that withed units exist but check that target is listed (as spec or
standalone body). Also store in a list, for each Unit_Name, the list of
paths where such unit exists.

Check redundant "with"
~~~~~~~~~~~~~~~~~~~~~~
For each unit build the tree of its parents (sub-unit -> body -> spec and if
spec is a child, list its praent units) and for each unit make the list of its
withed units.

For each unit U check that no withed unit W is withed twice by U or by a
parent of U, including indirect with of a child of W. Note that a redundant
"with" context clause is necessary (so accepted) in case of a "use" context
clause!

Exit program.

Build dependency tree
~~~~~~~~~~~~~~~~~~~~~
If in normal (not reverse) mode, start from target, process dependencies
recursively in this order:

  unit - ParentUnit
       - WithsOfSpec
       - WithsOfBody
       - WithsOfSububits

If in "specs only" mode don't insert body and subunits.

If in reverse mode, build a tree of:

  unit - WihtingUnit

If not in tree mode, keep a list of the PathUnit found so far and skip the processing
of a unit if it is already known.

Stop recursive search when reaching a non-standalone body or a subunit.

Display output
~~~~~~~~~~~~~~
In unit mode, only show specs and standalone bodies, otherwise (file mode)
show all entries.

Iterate on tree:

In tree mode
^^^^^^^^^^^^
Dump the tree:

  UnitSpec - WithsSpecs - WithsSpecs...
           - ParentSpec - WithsSpecs...
           - UnitBody - WithsSpecs...
                      - Subunits - WithSpecs...

In direct mode
^^^^^^^^^^^^^^
Dump the first level of tree:

  UnitSpec - WithsSpecs
           - UnitBody

In list mode
^^^^^^^^^^^^
Dump the tree in a list.

Sort it by unit/file path (local first).

In case of file revert mode, list each unit by spec+body+subunits.

In path mode
^^^^^^^^^^^^
Keep track in a list of the units between target and current unit.

When current unit is path_unit then show the current list.

