lsadeps
=======
V7.5

Lsadeps lists ada dependencies between files or units, optionally in reverse
order.

Alternatively it checks redundant "with" clauses between specs and bodies.

Command line arguments
----------------------
Usage: lsadeps <version> | <help> | <check> | <depend>

 <version>     ::= -v | --version
 <help>        ::= -h | --help
 <check>       ::= -c | --check  [ <target_dir> ]
 <depend>      ::= <options> <target_unit> [ <path_unit> ]
 <target_unit> ::=  [<path>/]<unit>
 <options>     ::=  [ <specs> | <revert> ] [ <tree> | <direct> ] [ <files> ] [ <include> ]
 <specs>       ::= -s | --specs
 <revert>      ::= -r | --revert
 <tree>        ::= -t | --tree
 <direct>      ::= -d | --direct
 <files>       ::= -f | --files
 <include>     ::= { <dir> | <recursive> }
 <dir>         ::= -I <dir> | --include=<dir>
 <recursive>   ::= -R <dir> | --recursive=<dir>

There are two main functions: List dependencies and check redundant "with".

List dependencies
~~~~~~~~~~~~~~~~~
This function by default lists units on which <target_unit> depends,
which are withed units, their body and subunits, units withed by these
units... recursively. +
Alternative modes are:

 - 'specs' to show only units withed by specs and standalone bodies,

 - 'revert' to show units withing <target_unit>... recursively.

 - 'path_unit' to show dependency paths between two units.

Other options are:

 - 'tree' to show the tree of dependencies (instead of a sorted unique list),

 - 'direct' to show only the units that are directly dependent,

 - 'file' to show the file names (instead of unit names),

 - 'include' to add some directories or some directory trees to the search path
   (default is current and target directories).


'Specs' and 'revert' modes are mutually exclusive. +
'Tree' and 'direct' mode are mutually exclusive. +
'Path mode and 'tree' are mutually exclusive.

Check redundant "with"
~~~~~~~~~~~~~~~~~~~~~~
This function shows redundant "with" clauses in a dir (default: current
dir). +
It does not support any option (even includes), only one optional 'target'
directory.

Format of output
----------------

Results are put on stdout.

List dependencies
~~~~~~~~~~~~~~~~~
There are 4 different modes of analyze of dependencies (that can be combined)
and 2 options of output:

- default mode: show parent units of target, then withed units, then body
and subunits... recursively

- specs mode: same as default but only show units withed by specs

- revert mode: show units withing target, then units withing them... recursively

- path mode: shows the units withed by (or withing) each other between two units

- tree option: show tree of dependencies instead of list

- direct option: show direct dependencies (show first level of tree)

- files option: show file names instead of units

In list mode local units are listed first, then "remote" ones in the order of
the include directives and they are sorted by alphabetical order. In tree
and direct modes the units appear in the same order as in the "with" directives.

By default the search is restricted to local directory and target directory
(and path_unit directory if any), but additional directories can be added to
the search path, either individually or recursively.

A local unit, if any exists, hides all the remote ones.

Example: suppose that a unit U withes a unit W.

- in normal (non revert) mode all remote units W are discarded if there is a
unit W co-located with U.

- in revert mode, a remote unit W withing unit U is discarded if there is
another unit U co-located with W.

- if there is no co-located unit then all the remote units with the same name
are processed identically (they are all considered to depend on or to be
dependent from current unit).

Check redundant "with"
~~~~~~~~~~~~~~~~~~~~~~
This function checks that no redundant "with" clause appear in the body and
sub-units of each unit.

It reports redundancy with messages like: +
"'Unit <unit> withes <withed> already withed by parent <unit>'", +
- where <unit> is the path of the unit, followed by '#', then either 'US' (Unit
Spec), 'UB' (Unit Body) or 'SU' (SubUnit) +
- and <withed> is the name of the redundant withed unit.

Example:

  Unit lsadeps/Output#UB withes Sourcer already withed by parent lsadeps/Output#US

lsadeps then exits with 1 if at least one redundant "with" is detected and
with 0 otherwise.

Examples
--------

What are the units needed by 'Unit'
--------------------
  lsadeps Unit (or lsadeps unit)
--------------------

What are the units, including those of the repository, needed by 'Unit'
--------------------
  lsadeps -I ~/ada/reposit Unit
--------------------

What are all the files needed to build 'Unit'
--------------------
  lsadeps -f -I ~/ada/reposit Unit
--------------------

How does 'Unit1' need 'Unit2'
--------------------
  lsadeps Unit1 Unit2
--------------------

What are all the units that will be re-compiled due to a modification of
Unit spec
--------------------
  lsadeps -r -R ~/ada/usr Unit
--------------------

Check redundant "with" in current directory
--------------------
  lsadeps -c
--------------------

High level design
-----------------
Parse and check arguments
~~~~~~~~~~~~~~~~~~~~~~~~~
- in dependency mode, target is a unit (possibly containing a path). An
optional path_unit triggers the path analysis between the target and this unit

- include dirs (recursive or not) must exist

- in check mode it is an optional path that denotes the directory to check

Parse ada sources
~~~~~~~~~~~~~~~~~
List and parse all ada sources in current and included dirs. For each file,
store in a list:

- kind: UnitSpec/UnitBody/SubUnit (US/UB/SU)

- Unit_Name, Mixed_Str.

- Path of the unit (directory where it is located)

- File name

- StandAlone indicator, boolean, if spec without body or body without spec

- Unit_Name of parent (if child spec, child body or subunit)

- List of withed unit names: @\Name@Name...@

- List of used unit names: @\Name@Name...@

- List of subunits names (if body or subunit): @\Name@Name...@

"Path/Unit_Name#Kind" is the unique access key.  A spec, its body and its
subunits must be collocated in the same directory.

No check that withed units exist but check that target is listed (as spec or
standalone body). Also store in a list, for each Unit_Name, the list of
paths where such unit exists.

Check redundant "with"
~~~~~~~~~~~~~~~~~~~~~~
For each unit build the tree of its parents (sub-unit -> body -> spec) and for
each unit make the list of its withed units.

For each unit U check that no withed unit W is withed twice by U or by a
parent of U, including indirect with of a child of W. Note that a redundant
"with" context clause is necessary (so accepted) in case of a "use" context
clause!

Exit program.

Build dependency tree
~~~~~~~~~~~~~~~~~~~~~
If in normal (not reverse) mode, start from target, process dependencies
recursively in this order:

  unit - ParentUnit
       - WithsOfSpec
       - WithsOfBody
       - WithsOfSububits

If in "specs only" mode don't insert body and subunits. If in reverse mode,
build a unique list of units that list targets, of units that list these
units. Stop recursive search when reaching a non-standalone body or a subunit.

Display output
~~~~~~~~~~~~~~
In unit mode, only show specs and standalone bodies, otherwise (file mode)
show all entries.

Iterate on tree:

In tree mode
^^^^^^^^^^^^
Dump the tree:

  UnitSpec - WithsSpecs - WithsSpecs...
           - ParentSpec - WithsSpecs...
           - UnitBody - WithsSpecs...
                      - Subunits - WithSpecs...

In direct mode
^^^^^^^^^^^^^^
Dump the first level of tree:

  UnitSpec - WithsSpecs
           - UnitBody

In list mode
^^^^^^^^^^^^
Dump the tree in a list.

Sort it by unit/file path (local first).

In case of file revert mode, list each unit by spec+body+subunits.

In path mode
^^^^^^^^^^^^
Keep track in a list of the units between target and current unit.

When current unit is path_unit then show the current list.

