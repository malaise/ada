# Replace top of stack by its int (uses register z)
[
# Round v in z
dup dup tointe toreal  z copyr swap 0.0 >= 
# v >= 0.0 : if v < R then R:=R-1
[ < [ z pushr 1.0 - z popr ] ifcall ]
# v < 0.0  : if v > R then R:=R+1
[ > [ z pushr 1.0 + z popr ] ifcall ]
ifte call
z pushr
] I popr

# Replace top of stack by its abs
[ dup 0.0 < [ +- ] ifcall ] A popr

# Can top of stack be assimilated to 0.0
[ A pushr call 1.0e-17 < ] Z popr

# Replace top of stack by its frac
[ dup
# Int
I pushr call - ] F popr

# Error, replace by 0.0 exit
[ [ Invalid entry:  ] put v pushr putl pop 0.0 ] E popr

# Check that top of stack is valid and fix it
# Replace it by mn, hh
[
# Make a real if needed
dup [ toreal ] swap isinte swap ifcall
# * 100,  Frac should be 0
dup 100.0 * F pushr call Z pushr call ~ E pushr ifcall
# Frac < 60
dup F pushr call 100.0 * 60.0 >= E pushr ifcall
# Push minutes then hours
dup F pushr call 100.0 * tointe
swap I pushr call tointe
] C popr

# Loop
[
# Return if no more data in stack
ssize 0 = 1 ifretn
# Store value for error tracing
v copyr
# Check 
C pushr call
# Add
h pushr + h popr
m pushr + m copyr
# Propagate the carry
60 > [ m pushr 60 - m popr h pushr 1 h popr ] ifcall
# Loop
L pushr retacal ] L popr

# Init sum and format
0 h popr
0 m popr
3.003 format

# Loop on data
L pushr call

# Display result
h pushr 5 format put [ h ] put m pushr  2 format putl

