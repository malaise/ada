# Error and quit
4 //
[ [ Error, 3 arguments: <nb_disks> <from_column> <to_column expected> ] ;
  [ "   nb_disks must be >= 0," ] ;
  [ "   columns must be 1, 2 or 3 and different." ] ;
0 __ ] E ->

# Check 3 args
. 3 /= E <- ?@

# Store args j=dest, i=origin, n=nb_disks
j -> i -> n ->

# Init total moves
0 t ->

# Check arguments  1 <= i j <= 3  and  i /= j  and 1 <= n 
i <- ?! ~ E <- ?@ j <- ?! ~ E <- ?@ n <- ?! ~ E <- ?@
i <- 1 < E <- ?@ i <- 3 > E <- ?@ j <- 1 < E <- ?@ j <- 3 > E <- ?@
i <- j <- = E <- ?@
n <- 1 < E <- ?@

# Compute other axis from i, j and push it instead
[ >< 1 = [ -- 2 = 3 2 ? 2 __ ] ?@ 2 = [ 3 = 1 3 ? 2 __ ] ?@ 2 = 1 2 ? ] K ->

# M(i, j, d) Move a disk: display
[ t <- 1 + t -> [ "move disk" ] , , <> [ " from" ] , , [ " to" ] , ; ] M ->

# Move disk 1: Move and return
[ M <- @ 2 __ ] T ->

# H(i, j, d): H(i, k, d-1), M(i, j, d), H(k, j, d-1)
# Stack of arguments: d j i
# H(i, j, 1): T(i, j, 1)
[ >< 1 = T <- ?@
# Save arguments in registers
d -> j -> i => j <- d <-
# Compute K(i, j)
j <- i <- K <- @
k =>
# Save
# H(i, k, d-1)
i <- k <- d <- 1 - H <- @
# Restore registers: k d j i
k -> d -> j -> i ->
# M(i, j, d)
i <- j <-  d <- M <- @
# H(k, j, d-1)
k <- j <- d <- 1 - H <- @
] H ->

# H(i, k, n)
i <- j <- n <- H <- @

# Done
7 //
[ Nb moves: ] , t <- ;

