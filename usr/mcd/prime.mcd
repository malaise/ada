# Put prime numbers

# Error Handling
[ "Usage: prime [ <max_number> ]" putl ssize popn retall ] E popr

# Store max in m if set
ssize 0 = [ 0 ] ifcall
ssize 1 /= E pushr ifcall
dup isinte ~ E pushr ifcall
m popr

# Loop on all extra stack
#  j has to be initialised to 0
#  Top of stack has to be true and is replaced by False if i not prime
[
# Done (j = n)?
esize j pushr = ifret
# Check next
j pushr 1 + j popr
# Check sqrt(i) < fe => prime
pushfe copye e copyr
s pushr > dup [ j pushr rotle ] ifcall ifret
# Check i % fe. 0 => not prime
i pushr e pushr % 0 =
# Not prime, restore estack (rotate j times from last)
dup [ j pushr rotle swap pop false swap ] ifcall ifret
L pushr retacal ] L popr


# Loop on all numbers
[
# Check current i (store sqrt(i))
i pushr toreal 0.5 ** round s popr
0 j popr true L pushr call
# I prime?  Put it and insert in estack
[ i pushr copye putl ] ifcall
# Next i
i pushr 1 + i popr
# Stop loop f m /= 0 and then m < j
m pushr dup 0 /= swap i pushr < & ifret
# Infinite loop or up to m
S pushr retacal ] S popr


# 1 is prime
4 format
1 putl
m pushr 1 = ifret


# First number to check
2 i popr
S pushr call

