with Lower_Str, Text_Line, Dynamic_List;
separate (Afpx_Bld)
package body Xref is

  Dscr_Num : constant String := "Dscr_Num";
  -- When an identifier is redefined, get line of previous definition
  Prev_Line_No : Natural := 0;
  function Prev_Name_Line return Natural is
  begin
    return Prev_Line_No;
  end Prev_Name_Line;


  procedure Check_Identifier (Name : in String) is
    use type Ada_Words.Keyword_Res_List;
  begin
    if not Ada_Words.Is_Identifier (Name) then
      raise Invalid_Identifier;
    end if;
    if Ada_Words.Check_Keyword (Name) /= Ada_Words.False then
      raise Invalid_Identifier;
    end if;
  end Check_Identifier;

  -- The package and file name, set once
  Package_Name, File_Name : Asu_Us;
  procedure Set_Package_Name (Name : in Asu_Us) is
  begin
    Check_Identifier (Name.Image);
    Package_Name := As.U.Tus (Mixed_Str (Name.Image));
    File_Name := As.U.Tus (Lower_Str (Name.Image) & ".ads");
  end Set_Package_Name;

  -- The descriptor names
  type Dscr_Rec is record
    Name : Asu_Us;
    Line_No : Natural := 0;
  end record;
  type Dscr_Array is array (Afpx_Typ.Descriptor_Range) of Dscr_Rec;
  Dscrs : Dscr_Array;
  -- The field names, a dummy field (0) for the Dscr
  type Field_Cell is record
    Dscr : Afpx_Typ.Descriptor_Range;
    Num  : Afpx_Typ.Absolute_Field_Range;
    Name : Asu_Us;
    Line_No : Natural;
  end record;
  package Field_List_Mng is new Dynamic_List (Field_Cell);
  package Field_Dyn_List_Mng renames Field_List_Mng.Dyn_List;
  Fields : Field_Dyn_List_Mng.List_Type;

  procedure Set_Dscr_Name (Dscr : in Afpx_Typ.Descriptor_Range;
                           Name : in Asu_Us;
                           Line : in Natural) is
    use type Afpx_Typ.Descriptor_Range, Asu_Us;
  begin
    Check_Identifier (Name.Image);
    Dscrs(Dscr) := (As.U.Tus (Mixed_Str (Name.Image)), Line);
    for I in Dscrs'Range loop
      if I /= Dscr and then Dscrs(I).Name = Dscrs(Dscr).Name then
        Prev_Line_No := Dscrs(I).Line_No;
        raise Identifier_Redefined;
      end if;
    end loop;
    Fields.Insert ( (Dscr, 0, Dscrs(Dscr).Name, Dscrs(Dscr).Line_No) );
  end Set_Dscr_Name;

  function Match (Current, Criteria : Field_Cell) return Boolean is
    use type Afpx_Typ.Descriptor_Range, Afpx_Typ.Absolute_Field_Range,
             Asu_Us;
  begin
    -- A field can have the same name as the descriptor
    return   Current.Num /= 0
    and then Current.Dscr = Criteria.Dscr
    and then Current.Name = Criteria.Name;
  end Match;
  procedure Set_Field_Name (Dscr  : in Afpx_Typ.Descriptor_Range;
                            Field : in Afpx_Typ.Field_Range;
                            Name  : in Asu_Us;
                            Line  : in Natural) is
    Cell : Field_Cell;
    Dummy : Boolean;
    pragma Unreferenced (Dummy);
  begin
    Check_Identifier (Name.Image);
    if Name.Image = Dscr_Num then
      raise Invalid_Identifier;
    end if;
    Cell := (Dscr, Field, As.U.Tus (Mixed_Str (Name.Image)), Line);
    Fields.Insert (Cell);
    -- Check no duplicates
    if Field_Dyn_List_Mng.Search_Match (Fields, Match'Access, Cell,
                          Occurence => 2,
                          From => Field_Dyn_List_Mng.Absolute) then
      Dummy := Field_Dyn_List_Mng.Search_Match (Fields, Match'Access, Cell,
                                       From => Field_Dyn_List_Mng.Absolute);
      Fields.Read (Cell, Field_Dyn_List_Mng.Current);
      Prev_Line_No := Cell.Line_No;
      raise Identifier_Redefined;
    else
      Fields.Rewind (Where => Field_Dyn_List_Mng.Prev);
    end if;
  end Set_Field_Name;

  -- Clean all dscr and field names
  procedure Clean is
  begin
    Dscrs := (others => <>);
    Fields.Delete_List (Deallocate => False);
  end Clean;

  -- Generate the file if the package name has been set
  procedure Generate is
    File : Text_Line.File_Type;
    Dscr : Natural;
    Cell : Field_Cell;

    procedure Close is
    begin
      if Dscr /= 0 then
        File.Put_Line ("  end "
              & Dscrs(Afpx_Typ.Descriptor_Range(Dscr)).Name.Image & ";");
      end if;
    end Close;
    use type Afpx_Typ.Absolute_Field_Range;
  begin
    if Package_Name.Is_Null then
      return;
    end if;
    File.Create_All (File_Name.Image);
    File.Put_Line ("-- Generated by afpx_bld");
    File.Put_Line ("with Afpx;");
    File.Put_Line ("package " & Package_Name.Image & " is");
    -- Dscrs here
    Dscr := 0;
    if not Fields.Is_Empty then
      Fields.Rewind;
      loop
        Fields.Get (Cell);
        if Cell.Num = 0 then
          -- New descriptor
          -- End previous descriptor
          Close;
          -- Start new descriptor
          Dscr := Positive (Cell.Dscr);
          File.Put_Line ("  package " & Dscrs(Cell.Dscr).Name & " is");
          File.Put_Line ("    " & Dscr_Num
                         & " : constant Afpx.Descriptor_Range := "
                         &  Normal (Positive (Cell.Dscr), 2, Gap => '0')
                         & ";");
        else
            File.Put_Line ("    " & Cell.Name.Image
              & " : constant Afpx.Field_Range := "
              & Normal (Positive (Cell.Num), 3, Gap => '0')
              & ";");
          null;
        end if;
        if Fields.Is_Empty then
          -- Close last descriptor
          Close;
          exit;
        end if;
      end loop;
    end if;
    File.Put_Line ("end " & Package_Name.Image & ";");
    File.Close_All;
  end Generate;

end Xref;

