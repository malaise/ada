-- This package implements the LZ4 lossless data compression algorithm. LZF is
-- a Lempel-Ziv variant with byte-aligned output, and optimized for speed.

-- Safety/Use Notes:
--  - The byte arrays should be smaller than 2 GB (Positive'Last).
--  - For performance reasons, safety checks on expansion are omitted.
--  - Invalid compressed data can cause exceptions (Constraint_Error)

-- General principles:
-- The LZ4 compressed format knows literal runs and back-references:
--  - Literal run: directly copy bytes from input to output.
--  - Back-reference: copy previous data of the uncompressed stream to the
--    output stream, with specified offset from location in the uncompressed
--    stream and length. The length is at least 4 bytes.
-- The compression algorithm is
--  - Read next byte and the 3 following bytes, these 4 bytes are the "future",
--    hash them
--  - Read the corresponding hash entry and replace the entry by current input
--    index (so, for a hash value, there is always the most recent index)
--  - If the read entry is set, then it is an index. Compare the four bytes at
--    this reference index with the current "future"
--  - If they match, then check how long of the reference matches current text
--    and append a cross reference (with offset from current and length of
--    match)
--  - If no match, then append the current byte as literal.
--  - The compressed flow is a suite of sequences. A sequence contains a run of
--    litteral then a cross reference. It is made of:
--    * A token: The first 4 bits indicate the length of the litteral run
--      and last 4 bits indicate the length of the corss reference
--    * Then, if the run is longer than 14, the token contains Fx and the
--      following (up to four) bytes contain the remaining of the length
--      Exemple, a length of 300 is coded as Fx FF 1E (15+255+30). (x is used
--      to code the length of the cross reference)
--    * Then the litteral run (if any)
--    * Then on two bytes little endian the offset of the cross reference
--      (1 for current - 1)
--    * Then, if the reference is longer than 14, the (up to four bytes) to
--      complete the length.
--    The last sequence contains only a token, possible extension of litteral
--     run length, and litterals.

-- The uncompression algorithm is
--  - Read a token, read the complement of litteral run length if needed,
--  - Copy the literals from input
--  - Read the offset, read the complement of reference length if needed
--  - Copy the reference from output

with Bit_Ops; use Bit_Ops;
with Long_Longs;
--#IfDef Debug
with Trace, Hexa_Utils;
--#EndifDef
pragma Optimize (Time);
package body Lz4 is

  --#IfDef Debug
  -- Trace logger
  package Logger is new Trace.Basic_Logger ("Lzf");
  procedure Log (Msg : in String) is
  pragma Inline (Log);
  begin
    Logger.Log_Debug (Msg);
  end Log;
  -- Image of a byte
  function Image is new Hexa_Utils.Mod_Image (Byte);
  --#EndifDef

  -- The number of entries in the hash table. The size is a trade-off between
  --  hash collisions (reduced compression) and speed (amount that fits in CPU
  --  cache)
  Hash_Log : constant := 17;
  Hash_Size : constant Natural := Shl (1, Hash_Log);
  -- Hash table: indexes are the hash of future and values are indexes
  --  in the input flow
  subtype Hash_Range is Integer range -1 .. Integer'Last;
  subtype Hash_Ref is Hash_Range range 0 .. Hash_Range'Last;
  Hash_Table : array (0 .. Hash_Size - 1) of Integer;

  -- The initial value of the Hash_Table
  Default_Hash : constant Hash_Range := -1;

  -- The maximum offset allowed for a back-reference (8192)
  -- The offset is stored in 16 bits -> FFFF
  Max_Off : constant Natural := Shl (1, 16);

  -- The representaion of 4 succesive bytes of input
  subtype Seq_Type is Integer;

  -- Init the future
  -- Bytes at Pos, Pos+1, Pos+2, Pos+3
  function Build (A : Byte_Array; I : Natural) return Seq_Type is
  pragma Inline (Build);
  begin
    return Shl (Integer(A(A'First + I + 0)), 24)
        or Shl (Integer(A(A'First + I + 1)), 16)
        or Shl (Integer(A(A'First + I + 2)),  8)
        or      Integer(A(A'First + I + 3));
  end Build;

  -- Compute the hash value of a Seq
  function Hash (V : Seq_Type) return Hash_Ref is
  pragma Inline (Hash);
  begin
    return Hash_Ref (Shr (Long_Long_Integer (V) * 2654435761, 32 - Hash_Log));
  end Hash;

  -- Convert an int into a byte
  function To_Byte (I : Natural) return Byte is
  pragma Inline (To_Byte);
  begin
    return Byte (I and 16#FF#);
  end To_Byte;

  -- Encode a length on several successive Out_Pos of Output
  procedure Encode_Length (Val : in Natural; Out_Pos : in out Positive;
                                             Output : in out Byte_Array) is
    Res : Natural := Val;
  begin
    loop
      if Res >= 16#FF# then
        Output(Out_Pos) := 16#FF#;
        Res := Res - 16#FF#;
        Out_Pos := Out_Pos + 1;
      else
        Output(Out_Pos) := To_Byte (Res);
        Out_Pos := Out_Pos + 1;
        exit;
      end if;
    end loop;
  end Encode_Length;


  -- Compress Input into Output
  -- May raise Too_Big if Output is too small
  procedure Compress (Input  : in Byte_Array;
                      Output : out Byte_Array;
                      Outlen : out Natural) is
    -- Indexes in input and output flows
    In_Pos, Anchor : Natural := 0;
    Src_Limit : constant Integer := Output'Length - 4;
    Out_Pos : Positive := Output'First;
    -- Current, next, next-next and next-next-next bytes
    Seq : Seq_Type;
    -- For increasing step of search
    Incompressible : constant := 128;
    Unmatch_Limit : Positive := Incompressible;
    Match_Step : Positive := 1;
    -- Number of literal in current run
    Nb_Literals : Integer := 0;
    -- Absolute and relative index, in input, of cross reference
    Hashed : Hash_Ref;
    Ref : Hash_Range;
    Off : Integer;
    use type C_Types.Byte;
  begin
    if Output'Length = 0 then
      if Input'Length = 0 then
        Outlen := 0;
        return;
      else
        raise Too_Big;
      end if;
    end if;
    Out_Pos := Output'First;

    --#IfDef Debug
    if Logger.Debug_On then
      Log ("Starting encoding from index " & Hexa_Utils.Image (Input'First)
         & " to " & Hexa_Utils.Image (Input'Last));
    end if;
    --#EndifDef

    -- Init
    Hash_Table := (others => Default_Hash);

    -- Main loop
    while In_Pos < Src_Limit loop

      -- Build sequence, hash it, read and replace Hash table content
      Seq := Build (Input, In_Pos);
      Hashed := Hash (Seq);
      Ref := Hash_Table(Hashed);
      Hash_Table(Hashed) := In_Pos;
      Off := In_Pos - Ref;
      --#IfDef Debug
      if Logger.Debug_On then
        Log ("At inpos " & Hexa_Utils.Image (In_Pos)
           & " Seq " & Hexa_Utils.Image (Long_Longs.Ll_Natural(Seq))
           & " Hashed as " & Hexa_Utils.Image (Hashed)
           & " got " & (if Ref = Default_Hash then "Default"
                        else Hexa_Utils.Image (Ref)) );

      end if;
      --#EndifDef

      if Ref = Default_Hash                  -- No reference
      or else Off > Max_Off                  -- Reference too far backwards
      or else Seq /= Build (Input, Off) then -- Hash matches but not seq

        -- No match: search another following byte
        if In_Pos - Anchor > Unmatch_Limit then
          -- After Unmatch_Limit failures we consider that the flow is not
          --  compresible, so we increase the step and the limit
          Unmatch_Limit := Shl (Unmatch_Limit, 1);
          Match_Step := Match_Step + 1 + Shr (Match_Step, 2);
        end if;
        In_Pos := In_Pos + Match_Step;
      elsif Match_Step > 1 then
         -- Match while stepping by more than one
         -- Restart just after previous matching failure
         Hash_Table(Hashed) := Ref;
         In_Pos := In_Pos - (Match_Step - 1);
         Match_Step := 1;
       else
         -- Match while stepping by one

         -- Reset the stepping values
         Unmatch_Limit := Incompressible;

         -- Encode then length of literal run seen so far
         Nb_Literals := In_Pos - Anchor;
         if Nb_Literals < 16#F# then
           -- Stored in 4 bits (upper quartet of token)
           Output (Out_Pos) := To_Byte (Shl (Nb_Literals, 4));
         else
           -- Stored on 4 bits and several successive bytes
           Output (Out_Pos) := 16#F0#;
           Out_Pos := Out_Pos + 1;
           Encode_Length (Nb_Literals - 16#F#, Out_Pos, Output);
         end if;


      end if;

    end loop;

  end Compress;

  -- Uncompress Input into Output
  -- May raise Too_Big if Output is too small
  -- May raise Invalid if input is not a valid compressed buffer
  procedure Uncompress (Input  : in Byte_Array;
                        Output : out Byte_Array;
                        Outlen : out Natural) is
  begin

    null;
  end Uncompress;

end Lz4;

